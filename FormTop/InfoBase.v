Require Import Coq.Program.Basics
  FormTop.FormTop FormTop.Cont Frame Algebra.Sets
  Morphisms.

Local Open Scope Ensemble.

(** Information bases, which are the predicative versions of
    Scott domains. Perhaps, see Definition 1.9 of [2].
    Though my formulation is a little different; I build off
    of a pre-existing notion of a meet semi-lattice.

    Also, I directly show that this formal topology is
    inductively generated by generating it with an axiom set. *)
Module InfoBase. 
Section InfoBase.

Generalizable Variables leS eqS. 

Context {S : Type} `{PO : PO.t S leS eqS}.

(** The axiom set essentially says that if [s <= t], then
    [s] is covered by the singleton set [{t}]. *)
Definition Ix (s : S) : Type := { t : S & leS s t }.
Definition C (s : S) (s' : Ix s) : Ensemble S := eqS (projT1 s').

(** This axiom set is localized. *)
Definition loc : FormTop.localized leS C.
Proof.
pose proof (@PO.t_equiv _ _ _ PO) as eqEquiv.
unfold FormTop.localized. intros. simpl.
unfold Ix, C in *.
destruct i. simpl.
assert (leS a a).
apply PreO.le_refl.
exists (existT _ a H0).
intros.  simpl in *. 
exists x. split. reflexivity.
split. 
rewrite H1. apply PreO.le_refl.
rewrite <- H1.
eapply PreO.le_trans. eapply H. eassumption.
Qed.

Definition Cov (s : S) (U : Ensemble S) : Prop :=
  In (FormTop.downset leS U) s.

(** The covering relation for information bases,
    which we derive from the axiom set above. *)
Definition GCov := @FormTop.GCov _ leS Ix C.

Require Import Morphisms SetoidClass.
Theorem CovEquiv : forall s U, Cov s U <-> GCov s U.
Proof.
intros. unfold Cov, GCov. split; intros.
- destruct H as [t Ut st].
  apply FormTop.ginfinity with (existT _ t st).
  unfold C. simpl. intros.
  apply FormTop.gle_left with t.
  rewrite H. apply PreO.le_refl.
  apply FormTop.grefl. assumption.
- induction H. 
  + exists a. assumption. unfold flip. apply PreO.le_refl.
  + destruct IHGCov as [t Ut bt].
    exists t. assumption. unfold flip. eapply PreO.le_trans; eassumption.
  + destruct i. unfold C in *. simpl in *.
    assert (eqS x x) as eqx. reflexivity.
    specialize (H x eqx).
    specialize (H0 x eqx). destruct H0 as [t Ut xt].
    exists t. assumption. unfold flip in *. eapply PreO.le_trans; eassumption.
Qed.

(** The proof that [Cov] is a valid formal topology. *)
Instance isCovG : FormTop.t leS GCov := 
  FormTop.GCov_formtop _ C loc.

Instance isCov : FormTop.t leS Cov.
Proof.
assert ((eq ==> eq ==> iff)%signature Cov GCov).
pose proof CovEquiv.
simpl_relation. rewrite H. apply isCovG.
Qed.

End InfoBase.
End InfoBase.

Module InfoBaseCont.
Section InfoBaseCont.

Generalizable All Variables.

Context {S} {leS : S -> S -> Prop} {POS : PreO.t leS}.
Context {T} {leT eqT : T -> T -> Prop} {POT : PO.t leT eqT}.

Record ptNM {F : Ensemble T} : Prop :=
  { ptNM_local : forall {a b}, F a -> F b -> 
     Inhabited (F ∩ FormTop.down leT a b)
  ; ptNM_le_right : forall a b, leT a b -> F a -> F b
  ; ptNM_here : Inhabited F
  }.

Arguments ptNM : clear implicits.

Instance ptNM_proper : Proper ((eq ==> iff) ==> iff) ptNM.
Proof.
Admitted.


(** I have no idea whether this is in fact
    a good definition *)
Record tNM {F_ : Cont.map S T} :=
  { NMle_left : forall a b c, leS a b -> F_ c b -> F_ c a
  ; NMle_right :  forall a b c, F_ b a -> leT b c -> F_ c a
  ; NMlocal : forall {a b c}, F_ b a -> F_ c a -> 
     Inhabited ((fun t => F_ t a) ∩ FormTop.down leT b c)
  ; NMhere : forall s : S, In (union (fun _ => True) F_) s
  }.

Arguments tNM : clear implicits.

Variable CovS : S -> Ensemble S -> Prop.
Hypothesis FTS : FormTop.t leS CovS.
Let CovT : T -> (T -> Prop) -> Prop := @InfoBase.Cov _ leT.

Theorem contNM : forall (F : Cont.map S T),
  tNM F
  -> Cont.t leS leT CovS CovT F.
Proof.
intros. constructor; intros.
- unfold InfoBase.Cov. apply FormTop.refl.
  apply (NMhere H).
- eapply (NMle_left H); eassumption. 
- unfold InfoBase.Cov. apply FormTop.refl. 
  pose proof (NMlocal H H0 H1).
  destruct H2. destruct H2. unfold In in H2.
  econstructor; eassumption.
- unfold CovT, InfoBase.Cov in *. 
  destruct H1 as [t0 Vt0 bt0].
  apply FormTop.refl. exists t0. assumption.
  apply (NMle_right H) with b; assumption.
Qed.

End InfoBaseCont.

Arguments tNM {_} leS {_} leT F_.
Arguments ptNM {_} leT F.

Section InfoBaseML.

Context {S} {leS : S -> S -> Prop} {POS : PreO.t leS}.
Context {T} `{MeetLat.t T}.

Record pt {F : Ensemble T} : Prop :=
  { pt_local : forall {a b}, F a -> F b -> F (MeetLat.min a b)
  ; pt_le_right : forall a b, MeetLat.le a b -> F a -> F b
  ; pt_here : Inhabited F
  }.

Arguments pt : clear implicits.

Instance pt_proper : Proper ((eq ==> iff) ==> iff) pt.
Proof.
Admitted.

Lemma down_min : forall a b,
 In (FormTop.down MeetLat.le a b) (MeetLat.min a b).
Proof.
intros. constructor; apply MeetLat.min_ok.
Qed.

Theorem pt_ptNM : forall F, pt F -> ptNM MeetLat.le F.
Proof.
intros. destruct H0. constructor; eauto.
intros. constructor 1 with (MeetLat.min a b).
econstructor. unfold In. eauto. apply down_min.
Qed.

(** I have no idea whether this is in fact
    a good definition *)
Record t {F_ : Cont.map S T} :=
  { le_left : forall a b c, leS a b -> F_ c b -> F_ c a
  ; le_right :  forall a b c, F_ b a -> MeetLat.le b c -> F_ c a
  ; local : forall {a b c}, F_ b a -> F_ c a -> 
     F_ (MeetLat.min b c) a
  ; here : forall s : S, In (union (fun _ => True) F_) s
  }.

Arguments t : clear implicits.

Variable CovS : S -> Ensemble S -> Prop.
Hypothesis FTS : FormTop.t leS CovS.
Let CovT : T -> (T -> Prop) -> Prop := @InfoBase.Cov _ MeetLat.le.

Theorem cont : forall (F : Cont.map S T),
  t F -> Cont.t leS MeetLat.le CovS CovT F.
Proof.
intros. apply contNM. assumption.
destruct H0. constructor; eauto.
intros. specialize (local0 _ _ _ H0 H1).
constructor 1 with (MeetLat.min b c).
constructor; eauto using down_min.
Qed.

Definition above_pt (x : T) : pt (MeetLat.le x).
Proof.
constructor; intros.
- apply MeetLat.min_ok; assumption.
- etransitivity; eassumption.
- econstructor. unfold In. reflexivity.
Qed.

Definition lift_op (f : S -> T) (y : T) (x : S) : Prop :=
  MeetLat.le (f x) y.

Definition lift_monotone (f : S -> T)
  (fmono : forall x y, leS x y -> MeetLat.le (f x) (f y))
  : t (lift_op f).
Proof.
constructor; unfold lift_op; intros.
- etransitivity. apply fmono. eassumption. assumption. 
- etransitivity; eassumption.
- apply MeetLat.min_ok; assumption.
- econstructor. unfold In. constructor. reflexivity.
Qed.

End InfoBaseML.

Arguments t {_} leS {_ _} F_.
Arguments pt {_} {_} F.
Arguments lift_op {_ _ _} f y x.

Section Product.

Context {S} `{MeetLat.t S}.
Context {T} `{MeetLat.t T}.
Context {U} `{MeetLat.t U}.

Definition lift_binop (f : S -> T -> U)
  (result : U) (args : S * T) : Prop :=
  let (l, r) := args in MeetLat.le (f l r) result.

Existing Instances MeetLat.product_ops MeetLat.product.

Theorem lift_binop_monotone : forall (f : S -> T -> U)
  (fmono : forall x x' y y', MeetLat.le x x' -> MeetLat.le y y' 
     -> MeetLat.le (f x y) (f x' y'))
  , t MeetLat.le (lift_binop f).
Proof.
intros. unfold lift_binop. constructor; intros.
- destruct a, b. simpl in *. unfold prod_op in *.
  destruct H2. rewrite <- H3. apply fmono; assumption.
- destruct a. rewrite <- H3.  assumption.
- destruct a. apply MeetLat.min_ok; assumption.
- destruct s. econstructor. constructor. 
  reflexivity.
Qed.

End Product.


Section Compose.

Context {S} {leS : S -> S -> Prop} {SOps} {MLS : MeetLat.t S SOps}.

Instance OneOps : MeetLat.Ops True := MeetLat.one_ops.

Theorem to_pt : forall (F : Cont.map True S), t MeetLat.le F ->
  pt (fun s => F s I).
Proof.
intros. constructor; intros.
- apply (local H); assumption. 
- eapply (le_right H); eassumption. 
- pose proof (here H I). destruct H0.
  econstructor; eauto.
Qed.

Theorem from_pt : forall (F : Ensemble S), pt F -> t MeetLat.le (fun t' _ => F t').
Proof.
intros. constructor; intros.
- assumption.
- eapply (pt_le_right H); eassumption.
- apply (pt_local H); assumption.
- pose proof (pt_here H). destruct H0. 
  repeat (econstructor || eauto).
Qed.

Context {T TOps} {MLT : MeetLat.t T TOps}.
Context {U UOps} {MLU : MeetLat.t U UOps}.

Theorem t_compose (F : Cont.map S T) (G : Cont.map T U)
  : t MeetLat.le F -> t MeetLat.le G
  -> t MeetLat.le (compose G F).
Proof.
intros HF HG.
constructor; unfold compose; intros.
- destruct H0 as (t & Fbt & Gtc).
  exists t. split. 
  + assumption. 
  + eapply (le_left HF); eassumption.
- destruct H as (t & Fat & Gtb).
  exists t. split. eapply (le_right HG); eassumption.
  assumption.
- destruct H as (t & Fat & Gtb).
  destruct H0 as (t' & Fat' & Gt'c).
  exists (MeetLat.min t t'). split. 
  + apply (local HG); eapply (le_left HG). 
    apply MeetLat.min_l. assumption. 
    apply MeetLat.min_r. assumption. 
  + apply (local HF); assumption.
- destruct (here HF s). destruct (here HG a).
  exists a0. constructor. exists a. auto.
Qed.

End Compose.

Section EvalPt.

Context {S SOps} {MLS : MeetLat.t S SOps}.
Context {T TOps} {MLT : MeetLat.t T TOps}.

Definition eval (F : Cont.map S T) (x : Ensemble S) (t : T) : Prop :=
  Inhabited (x ∩ F t).

Require Import Morphisms.
Theorem eval_pt (F : Cont.map S T) (x : Ensemble S)
  : pt x -> t MeetLat.le F -> pt (eval F x).
Proof.
intros Hx HF.
pose proof (t_compose (fun t _ => x t) F (from_pt _ Hx) HF).
apply to_pt in H. 
eapply pt_proper. 2: eassumption. simpl_relation.
unfold eval. split; intros.
- destruct H0. destruct H0. econstructor; eauto.
- destruct H0. destruct H0. repeat (econstructor || eauto).
Qed.

End EvalPt.

End InfoBaseCont.

Arguments InfoBaseCont.t {S} leS {T} {TOps} F : rename, clear implicits.

Module One.
Section One.

Definition Cov (_ : True) (U : True -> Prop) : Prop := U I.

Require Import Morphisms.
Theorem CovEquiv : (eq ==> eq ==> iff)%signature Cov (@InfoBase.Cov _ (fun _ _ => True)).
Proof.
simpl_relation.
intros. unfold Cov, InfoBase.Cov. split; intros.
- exists I; unfold flip; tauto.
- destruct H as [[] Ut _]. assumption.
Qed.

Instance MLOne : MeetLat.t True MeetLat.one_ops := MeetLat.one.
Instance POOne : @PO.t True (fun _ _ => True) (fun _ _ => True) := @MeetLat.PO _ _ MLOne.

Instance FTOne : FormTop.t (@MeetLat.le _ MeetLat.one_ops) Cov.
Proof.
rewrite CovEquiv.
apply InfoBase.isCov.
Qed.

Section One_intro.

Context {S : Type} {leS : S -> S -> Prop}
  {CovS : S -> Ensemble S -> Prop}
  {FTS : FormTop.t leS CovS}.

Definition One_intro (_ : True) (s : S)  : Prop := True.

Theorem One_intro_cont : 
  Cont.t leS (fun _ _ => True) CovS Cov One_intro.
Proof.
constructor; unfold One_intro; intros; simpl; try auto.
- apply FormTop.refl. unfold In; simpl. constructor 1 with I.
  unfold In; simpl; constructor. constructor.
- apply FormTop.refl. unfold In; simpl. 
  exists I. unfold FormTop.down, In; auto. constructor.
- unfold Cov in H0. apply FormTop.refl. constructor 1 with I.
  assumption. auto.
Qed.

End One_intro.

Instance one_ops : MeetLat.Ops True := MeetLat.one_ops.

Require Import Morphisms.
Definition FTtoFrame : 
  Frame.morph (FormTop.FOps MeetLat.le Cov) Frame.prop_ops (fun U => U I).
Proof.
simpl. unfold Cov.
constructor.
- constructor.
  + constructor. simpl. unfold FormTop.leA, FormTop.Sat, Cov.
    unfold PreO.morph. intros. 
    unfold Included, In in H. auto.
    simpl_relation. simpl in *. unfold FormTop.eqA, FormTop.Sat in *.
    unfold Same_set in *. destruct H.
    unfold Included, In in *. split; auto.
  + simpl. intros. split. intros. destruct H; tauto.
    intros. destruct H. left. assumption. right. assumption.
  + simpl. unfold FormTop.minA. unfold FormTop.downset, flip. intros.
    split; intros. destruct H. destruct H, H0.
    destruct x, a0, a1. auto.
    destruct H. constructor; econstructor; eauto. 
- simpl. intros. split; intros. destruct H. destruct s. 
  exists i. assumption. destruct H. econstructor; eauto.
- simpl. split; intros []; intros. 
  exists True. constructor. constructor 1 with (fun _ => True). constructor.
Qed.

Context {S} {leS : S -> Ensemble S} {POS : PreO.t leS}.
Variable CovS : S -> (Ensemble S) -> Prop.

Definition Point (f : Ensemble S) := Cont.t MeetLat.le leS Cov CovS (fun t _ => f t).

Hypothesis FTS : FormTop.t leS CovS.

Instance FrameS : Frame.t (Ensemble S) (FormTop.FOps leS CovS)
  := FormTop.Frame leS CovS _ FTS.

Instance FrameOne : Frame.t (True -> Prop) (FormTop.FOps MeetLat.le Cov)
  := FormTop.Frame MeetLat.le Cov _ FTOne.

Existing Instance Frame.prop.

Definition toFPoint (f : Ensemble S) (pointf : Point f) :
  Frame.cmap Frame.prop_ops (FormTop.FOps leS CovS) :=
  {| Frame.finv := fun x => Cont.frame (fun t _ => f t) x I 
  ; Frame.cont := Frame.morph_compose _ _
    (Cont.toFrame FTOne FTS (fun t _ => f t) pointf) FTtoFrame |}.

End One.
End One.

Module Discrete.
Section Discrete.

Generalizable All Variables.

Variable A : Type.

Hypothesis deceq : forall a a' : A, {a = a'} + {a <> a'}.

Definition Ix := @InfoBase.Ix _ (@Logic.eq A).
Definition C := @InfoBase.C _ (@Logic.eq A).
Definition CovI := @InfoBase.Cov _ (@Logic.eq A).

(** Woops I should have a positivity predicate to say that the
    "None" is covered by nothing *)
Definition Cov (a : A) (U : A -> Prop) : Prop := U a.

Require Import Morphisms.
Theorem CovEquiv : (eq ==> eq ==> iff)%signature CovI Cov.
Proof.
simpl_relation. unfold Cov, CovI, InfoBase.Cov.
split; intros.
- destruct H as [x t xt leat]. unfold flip in *. subst. assumption. 
-  exists y; unfold flip; auto.
Qed.

Instance FTproper : Proper _ FormTop.t := @FormTop.t_proper A.
Instance discretePO : PO.t Logic.eq Logic.eq := PO.discrete A.

Instance isCov : FormTop.t Logic.eq Cov.
Proof.
rewrite <- CovEquiv.
apply InfoBase.isCov.
Qed.

End Discrete.

Section FinFunc.

Context {A B : Type}.
Hypothesis deceqA : forall a a' : A, {a = a'} + {a <> a'}.
Hypothesis deceqB : forall b b' : B, {b = b'} + {b <> b'}.

Definition discrF (f : A -> B) (y : B) (x : A) : Prop := f x = y.

Instance POB : PO.t Logic.eq Logic.eq := PO.discrete B.

Ltac inv H := inversion H; clear H; subst.

Theorem fCont (f : A -> B) :
  Cont.t Logic.eq Logic.eq (Cov A) (Cov B) (discrF f).
Proof.
constructor; unfold Cov; intros.
- exists (f a); constructor.
- subst. assumption.
- inv H. inv H0. exists (f a). split; reflexivity.
  reflexivity.
- exists b; unfold In; auto.
Qed.

End FinFunc.

End Discrete.

Module Sierpinski.

Local Instance ops : MeetLat.Ops bool := MeetLat.two_ops.
Local Instance SML : MeetLat.t bool ops := MeetLat.two.

Definition Ix := InfoBase.Ix (leS := MeetLat.le).
Definition C := InfoBase.C (leS := MeetLat.le) (eqS := MeetLat.eq).

Definition sand : Cont.map (bool * bool) bool :=
  InfoBaseCont.lift_binop andb.

Existing Instances MeetLat.product MeetLat.product_ops.

Theorem sand_cont : InfoBaseCont.t MeetLat.le sand.
Proof.
apply InfoBaseCont.lift_binop_monotone.
simpl. intros. destruct x, x', y, y'; auto.
Qed.

Definition sor : Cont.map (bool * bool) bool :=
  InfoBaseCont.lift_binop orb.

Theorem sor_cont : InfoBaseCont.t MeetLat.le sor.
Proof.
apply InfoBaseCont.lift_binop_monotone.
simpl. intros. destruct x, x', y, y'; auto; congruence.
Qed.

Definition const_cont (b : bool) : InfoBaseCont.pt (MeetLat.le (negb b)).
Proof.
apply InfoBaseCont.above_pt.
Qed.

End Sierpinski.