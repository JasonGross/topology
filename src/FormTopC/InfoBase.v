Require Import Coq.Program.Basics
  FormTopC.FormTop FormTopC.Cont Algebra.FrameC Algebra.SetsC
  CMorphisms
  Prob.StdLib.

Set Universe Polymorphism.
Set Asymmetric Patterns.

Local Open Scope Subset.

(** Information bases, which are the predicative versions of
    Scott domains. Perhaps, see Definition 1.9 of [2].
    Though my formulation is a little different; I build off
    of a pre-existing notion of a meet semi-lattice.

    Also, I directly show that this formal topology is
    inductively generated by generating it with an axiom set. *)
Module InfoBase. 
Section InfoBase.

Generalizable Variables leS eqS. 

Context {S : Type} `{PO : PO.t S leS eqS}.

(** The axiom set essentially says that if [s <= t], then
    [s] is covered by the singleton set [{t}]. *)
Inductive Ix {s : S} : Type := 
  MkIx : forall t, leS s t -> Ix.

Arguments Ix : clear implicits.

Definition C (s : S) (s' : Ix s) : Subset S := match s' with
  | MkIx t _ => eqS t
  end.

(** This axiom set is localized. *)
Local Instance loc : FormTop.localized leS C.
Proof.
pose proof (@PO.t_equiv _ _ _ PO) as eqEquiv.
unfold FormTop.localized. intros. simpl.
destruct i. simpl.
assert (leS a a) as H0 by reflexivity.
exists (MkIx a H0). 
intros. simpl in *. clear H0.
exists t. split. reflexivity.
split. 
rewrite X0. reflexivity. 
rewrite <- X0. etransitivity; eassumption.
Qed.

Definition Cov (s : S) (U : Subset S) : Type :=
  In (FormTop.downset leS U) s.

(** The covering relation for information bases,
    which we derive from the axiom set above. *)
Definition GCov := @FormTop.GCov _ leS Ix C.

Theorem CovEquiv : forall s U, iffT (Cov s U) (GCov s U).
Proof.
intros. unfold Cov, GCov. split; intros.
- destruct X as [t Ut st].
  apply FormTop.ginfinity with (MkIx t st).
  unfold C. simpl. intros.
  apply FormTop.gle_left with t.
  rewrite X. reflexivity.
  apply FormTop.grefl. assumption.
- induction X. 
  + exists a. assumption. reflexivity.
  + destruct IHX as [t Ut bt].
    exists t. assumption. etransitivity; eassumption.
  + destruct i. unfold C in *. simpl in *.
    assert (eqS t t) as eqt by reflexivity.
    specialize (X t eqt).
    specialize (g t eqt). destruct X as [x Ux tx].
    exists x. assumption. etransitivity; eassumption.
Qed.

(** The proof that [Cov] is a valid formal topology. *)
Local Instance isCovG : FormTop.t leS GCov := 
  FormTop.GCov_formtop.

Local Instance isCov : FormTop.t leS Cov.
Proof.
assert ((eq ==> eq ==> iffT)%signature Cov GCov).
simpl_crelation. apply CovEquiv.
(** I should be able to replace Cov with GCov here
    and apply isCovG, but I don't have the t_Proper instance
    due to universe issues.
*)
Fail (rewrite <- X; apply isCovG).
Admitted.

Lemma Overt : FormTop.gtPos leS C.
Proof.
apply FormTop.gall_Pos.
intros. destruct i. simpl. exists t.
unfold In. reflexivity.
Qed.

End InfoBase.
End InfoBase.

Arguments InfoBase.Ix {S leS} s : clear implicits.

Module InfoBaseCont.
Section InfoBaseCont.

Generalizable All Variables.

Context {S} {leS : crelation S} {POS : PreO.t leS}.
Context {T} {leT eqT : crelation T} {POT : PO.t leT eqT}.

Record ptNM {F : Subset T} : Type :=
  { ptNM_local : forall {a b}, F a -> F b -> 
     Inhabited (F ∩ FormTop.down leT a b)
  ; ptNM_le_right : forall a b, leT a b -> F a -> F b
  ; ptNM_here : Inhabited F
  }.

Arguments ptNM : clear implicits.

Instance ptNM_proper : Proper ((eq ==> iffT) ==> iffT) ptNM.
Proof.
Admitted.


(** I have no idea whether this is in fact
    a good definition *)
Record tNM {F_ : Cont.map S T} :=
  { NMle_left : forall a b c, leS a b -> F_ c b -> F_ c a
  ; NMle_right :  forall a b c, F_ b a -> leT b c -> F_ c a
  ; NMlocal : forall {a b c}, F_ b a -> F_ c a -> 
     Inhabited ((fun t => F_ t a) ∩ FormTop.down leT b c)
  ; NMhere : forall s : S, In (union (fun _ => True) F_) s
  }.

Arguments tNM : clear implicits.

Variable CovS : S -> Subset S -> Type.
Hypothesis FTS : FormTop.t leS CovS.
Let CovT : T -> Subset T -> Type := @InfoBase.Cov _ leT.

Theorem contNM : forall (F : Cont.map S T),
  tNM F
  -> Cont.t leS leT CovS CovT F.
Proof.
intros. constructor; intros.
- unfold InfoBase.Cov. apply FormTop.refl.
  apply (NMhere X).
- eapply (NMle_left X); eassumption. 
- unfold InfoBase.Cov. apply FormTop.refl. 
  pose proof (NMlocal X X0 X1).
  destruct X2. destruct i.
  econstructor; eassumption.
- unfold CovT, InfoBase.Cov in *. 
  destruct X1 as [t0 Vt0 bt0].
  apply FormTop.refl. exists t0. assumption.
  apply (NMle_right X) with b; assumption.
Qed.

End InfoBaseCont.

Arguments tNM {_} leS {_} leT F_.
Arguments ptNM {_} leT F.

Section InfoBaseML.

Context {S} {leS : crelation S} {POS : PreO.t leS}.
Context {T} `{MeetLat.t T}.

Record pt {F : Subset T} : Type :=
  { pt_local : forall {a b}, F a -> F b -> F (MeetLat.min a b)
  ; pt_le_right : forall a b, MeetLat.le a b -> F a -> F b
  ; pt_here : Inhabited F
  }.

Arguments pt : clear implicits.

Instance pt_proper : Proper ((eq ==> iffT) ==> iffT) pt.
Proof.
Admitted.

Lemma down_min : forall a b,
 In (FormTop.down MeetLat.le a b) (MeetLat.min a b).
Proof.
intros. constructor; apply MeetLat.min_ok.
Qed.

Theorem pt_ptNM : forall F, pt F -> ptNM MeetLat.le F.
Proof.
intros F H0. destruct H0. constructor; eauto.
intros. constructor 1 with (MeetLat.min a b).
econstructor. unfold In. eauto. apply down_min.
Qed.

(** I have no idea whether this is in fact
    a good definition *)
Record t {F_ : Cont.map S T} :=
  { le_left : forall a b c, leS a b -> F_ c b -> F_ c a
  ; le_right :  forall a b c, F_ b a -> MeetLat.le b c -> F_ c a
  ; local : forall {a b c}, F_ b a -> F_ c a -> 
     F_ (MeetLat.min b c) a
  ; here : forall s : S, In (union (fun _ => True) F_) s
  }.

Arguments t : clear implicits.

Variable CovS : S -> Subset S -> Type.
Hypothesis FTS : FormTop.t leS CovS.
Let CovT : T -> Subset T -> Type := @InfoBase.Cov _ MeetLat.le.

Theorem cont : forall (F : Cont.map S T),
  t F -> Cont.t leS MeetLat.le CovS CovT F.
Proof.
intros. apply contNM. assumption.
destruct X. constructor; eauto.
intros. specialize (local0 _ _ _ X X0).
constructor 1 with (MeetLat.min b c).
constructor; eauto. apply down_min.
Qed.

Definition above_pt (x : T) : pt (MeetLat.le x).
Proof.
constructor; intros.
- apply MeetLat.min_ok; assumption.
- etransitivity; eassumption.
- econstructor. unfold In. reflexivity.
Qed.

Definition lift_op (f : S -> T) (y : T) (x : S) : Type :=
  MeetLat.le (f x) y.

Definition lift_monotone (f : S -> T)
  (fmono : forall x y, leS x y -> MeetLat.le (f x) (f y))
  : t (lift_op f).
Proof.
constructor; unfold lift_op; intros.
- etransitivity. apply fmono. eassumption. assumption. 
- etransitivity; eassumption.
- apply MeetLat.min_ok; assumption.
- econstructor. unfold In. constructor. reflexivity.
Qed.

End InfoBaseML.

Arguments t {_} leS {_ _} F_.
Arguments pt {_} {_} F.
Arguments lift_op {_ _ _} f y x.

Section Product.

Context {S} `{MeetLat.t S}.
Context {T} `{MeetLat.t T}.
Context {U} `{MeetLat.t U}.

Definition lift_binop (f : S -> T -> U)
  (result : U) (args : S * T) : Type :=
  let (l, r) := args in MeetLat.le (f l r) result.

Existing Instances MeetLat.product_ops MeetLat.product.

Theorem lift_binop_monotone : forall (f : S -> T -> U)
  (fmono : forall x x' y y', MeetLat.le x x' -> MeetLat.le y y' 
     -> MeetLat.le (f x y) (f x' y'))
  , t MeetLat.le (lift_binop f).
Proof.
intros. unfold lift_binop. constructor; intros.
- destruct a, b. simpl in *. unfold prod_op in *.
  destruct X. rewrite <- X0. apply fmono; assumption.
- destruct a. rewrite <- X0.  assumption.
- destruct a. apply MeetLat.min_ok; assumption.
- destruct s. econstructor. constructor. 
  reflexivity.
Qed.

End Product.


Section Compose.

Context {S} {leS : crelation S} {SOps} {MLS : MeetLat.t S SOps}.

Instance OneOps : MeetLat.Ops True := MeetLat.one_ops.

Theorem to_pt : forall (F : Cont.map True S), t MeetLat.le F ->
  pt (fun s => F s I).
Proof.
intros F H. constructor; intros.
- apply (local H); assumption. 
- eapply (le_right H); eassumption. 
- pose proof (here H I) as X. destruct X.
  econstructor; eauto.
Qed.

Theorem from_pt : forall (F : Subset S), pt F -> t MeetLat.le (fun t' _ => F t').
Proof.
intros F H. constructor; intros.
- assumption.
- eapply (pt_le_right H); eassumption.
- apply (pt_local H); assumption.
- pose proof (pt_here H) as X. destruct X. 
  repeat (econstructor || eauto).
Qed.

Context {T TOps} {MLT : MeetLat.t T TOps}.
Context {U UOps} {MLU : MeetLat.t U UOps}.

Theorem t_compose (F : Cont.map S T) (G : Cont.map T U)
  : t MeetLat.le F -> t MeetLat.le G
  -> t MeetLat.le (compose G F).
Proof.
intros HF HG.
constructor; unfold compose; intros.
- destruct X0 as (t & Fbt & Gtc).
  exists t. split. 
  + assumption. 
  + eapply (le_left HF); eassumption.
- destruct X as (t & Fat & Gtb).
  exists t. split. eapply (le_right HG); eassumption.
  assumption.
- destruct X as (t & Fat & Gtb).
  destruct X0 as (t' & Fat' & Gt'c).
  exists (MeetLat.min t t'). split. 
  + apply (local HG); eapply (le_left HG). 
    apply MeetLat.min_l. assumption. 
    apply MeetLat.min_r. assumption. 
  + apply (local HF); assumption.
- destruct (here HF s). destruct (here HG a).
  exists a0. constructor. exists a. auto.
Qed.

End Compose.

Section EvalPt.

Context {S SOps} {MLS : MeetLat.t S SOps}.
Context {T TOps} {MLT : MeetLat.t T TOps}.

Definition eval (F : Cont.map S T) (x : Subset S) (t : T) : Type :=
  Inhabited (x ∩ F t).

Theorem eval_pt (F : Cont.map S T) (x : Subset S)
  : pt x -> t MeetLat.le F -> pt (eval F x).
Proof.
intros Hx HF.
pose proof (t_compose (fun t _ => x t) F (from_pt _ Hx) HF) as H.
apply to_pt in H. 
eapply pt_proper. 2: eassumption. simpl_crelation.
unfold eval. split; intros.
- destruct X. destruct i. econstructor; eauto.
- destruct X. destruct p. repeat (econstructor || eauto).
Qed.

End EvalPt.

End InfoBaseCont.

Arguments InfoBaseCont.t {S} leS {T} {TOps} F : rename, clear implicits.

Module One.
Section One.

Local Instance MLOneOps : MeetLat.Ops True := MeetLat.one_ops.
Local Instance MLOne : MeetLat.t True MLOneOps := MeetLat.one.
Local Instance POOne : @PO.t True (fun _ _ => True) (fun _ _ => True) := @MeetLat.PO _ _ MLOne.

Definition Cov (_ : True) (U : Subset True) : Type := U I.
Definition Cov' := FormTop.GCov MeetLat.le 
  (InfoBase.C (leS := MeetLat.le) (eqS := MeetLat.eq)).

Theorem CovEquiv' : forall a U, iffT (Cov a U) (Cov' a U).
Proof.
intros. unfold Cov, Cov'. split; intros.
- apply FormTop.grefl. destruct a; assumption. 
- induction X; auto. destruct a; auto.
  apply (X I). destruct i. constructor.
Qed.

Theorem CovEquiv : (eq ==> eq ==> iffT)%signature Cov Cov'.
Proof.
simpl_crelation. apply CovEquiv'.
Qed.


Instance FTOne : FormTop.t (@MeetLat.le _ MeetLat.one_ops) Cov.
Proof.
(** This is a weird Coq error... *)
Fail rewrite CovEquiv.
(** Proof broken 
apply FormTop.GCov_formtop. apply InfoBase.loc.
Qed.
*)
Admitted.

Section One_intro.

Context {S : Type} {leS : crelation S}
  {CovS : S -> Subset S -> Type}
  {FTS : FormTop.t leS CovS}.

Definition One_intro (_ : True) (s : S) : Prop := True.

Theorem One_intro_cont : 
  Cont.t leS (fun _ _ => True) CovS Cov' One_intro.
Proof.
constructor; unfold One_intro; intros; simpl; try auto.
- apply FormTop.refl. unfold In; simpl. constructor 1 with I.
  unfold In; simpl; constructor. constructor.
- apply FormTop.refl. unfold In; simpl. 
  exists I. unfold FormTop.down, In; auto. constructor.
- apply FormTop.refl. constructor 1 with I.
  rewrite <- CovEquiv' in X. unfold Cov in X.
  assumption. auto.
Qed.

End One_intro.

Instance one_ops : MeetLat.Ops True := MeetLat.one_ops.

(** Why is this a universe inconsistency???
Definition FTtoFrame : 
  Frame.morph (FormTop.FOps MeetLat.le Cov) Frame.prop_ops (fun U => U I).
Proof.
simpl. unfold Cov.
constructor.
- constructor.
  + constructor. simpl. unfold FormTop.leA, FormTop.Sat, Cov.
    unfold PreO.morph. intros. 
    unfold Included, In in H. auto.
    simpl_relation. simpl in *. unfold FormTop.eqA, FormTop.Sat in *.
    unfold Same_set in *. destruct H.
    unfold Included, In in *. split; auto.
  + simpl. intros. split. intros. destruct H; tauto.
    intros. destruct H. left. assumption. right. assumption.
  + simpl. unfold FormTop.minA. unfold FormTop.downset, flip. intros.
    split; intros. destruct H. destruct H, H0.
    destruct x, a0, a1. auto.
    destruct H. constructor; econstructor; eauto. 
- simpl. intros. split; intros. destruct H. destruct s. 
  exists i. assumption. destruct H. econstructor; eauto.
- simpl. split; intros []; intros. 
  exists True. constructor. constructor 1 with (fun _ => True). constructor.
Qed.
*)

Context {S} {leS : S -> Subset S} {POS : PreO.t leS}.
Variable CovS : S -> (Subset S) -> Type.

Existing Instance Cont.t_Proper.

Theorem pt_to_map (f : Subset S) :
  Cont.pt leS CovS f -> Cont.t MeetLat.le leS Cov' CovS (fun t _ => f t).
Proof.
intros H. destruct H. destruct pt_here.
(** Another weird Coq error. *)
(*
Fail rewrite <- CovEquiv.
constructor; intros.
- apply FormTop.refl. econstructor. constructor.
  eassumption.
- assumption.
- apply FormTop.refl.
  destruct (pt_local _ _ H0 H1). destruct H2.
  econstructor. eassumption. assumption.
- destruct (pt_cov _ _ H0 H1). destruct H2. 
  econstructor; eassumption.
Qed.
*)
Admitted.

Definition Point (f : Subset S) := Cont.t MeetLat.le leS Cov CovS (fun t _ => f t).

Hypothesis FTS : FormTop.t leS CovS.

Local Instance FrameS : Frame.t (Subset S) (FormTop.FOps leS CovS)
  := FormTop.Frame leS CovS.

Local Instance FrameOne : Frame.t (Subset True) (FormTop.FOps MeetLat.le Cov)
  := FormTop.Frame MeetLat.le Cov.

Existing Instance Frame.prop.

(* Broken
Definition toFPoint (f : Subset S) (pointf : Point f) :
  Frame.cmap Frame.prop_ops (FormTop.FOps leS CovS) :=
  {| Frame.finv := fun x => Cont.frame (fun t _ => f t) x I 
  ; Frame.cont := Frame.morph_compose _ _
    (Cont.toFrame FTOne FTS (fun t _ => f t) pointf) FTtoFrame |}.
*)

End One.
End One.

Module Sierpinski.

Local Instance ops : MeetLat.Ops bool := MeetLat.two_ops.
Local Instance SML : MeetLat.t bool ops := MeetLat.two.

Definition Ix := InfoBase.Ix (leS := MeetLat.le).
Definition C := InfoBase.C (leS := MeetLat.le) (eqS := MeetLat.eq).

Definition sand : Cont.map (bool * bool) bool :=
  InfoBaseCont.lift_binop andb.

Existing Instances MeetLat.product MeetLat.product_ops.

Theorem sand_cont : InfoBaseCont.t MeetLat.le sand.
Proof.
apply InfoBaseCont.lift_binop_monotone.
simpl. intros. destruct x, x', y, y'; auto.
Qed.

Definition sor : Cont.map (bool * bool) bool :=
  InfoBaseCont.lift_binop orb.

Theorem sor_cont : InfoBaseCont.t MeetLat.le sor.
Proof.
apply InfoBaseCont.lift_binop_monotone.
simpl. intros. destruct x, x', y, y'; auto; congruence.
Qed.

Definition const_cont (b : bool) : InfoBaseCont.pt (MeetLat.le (negb b)).
Proof.
apply InfoBaseCont.above_pt.
Qed.

End Sierpinski.

Require Import
  FormTopC.Product
  Spec.Category
  FormTopC.Bundled
  FormTopC.Cont.
Import Category.

Local Open Scope loc.

Definition InfoBase {A : Type} {ops : MeetLat.Ops A}
  (ML : MeetLat.t A ops) : IGT :=
  {| S := A 
  ; PO := PO.PreO
  ; localized := @InfoBase.loc _ _ _ MeetLat.PO
  ; pos := InfoBase.Overt
  |}.

Definition One : IGT := InfoBase MeetLat.one.

Definition Σ : IGT := InfoBase Sierpinski.SML.

Definition Σand_mp : Cont.map (S (Σ * Σ)) (S Σ) := Sierpinski.sand.

(** I need to prove that a the information-base product of meet lattices
    is the same as the product of the information bases

    This will be phrased as a homeomorphism!
*)
(** Sierpinski.sand_cont *)
Definition Σand_mp_ok : Cont.t (le (Σ * Σ)) (le Σ)
  (Cov (Σ * Σ)) (Cov Σ) Σand_mp.
Proof.
simpl. unfold Cov. simpl. 
Admitted.

Definition Σand : Σ * Σ ~~> Σ :=
  {| mp := Σand_mp
   ; mp_ok := Σand_mp_ok
  |}.

Definition Σor_mp : Cont.map (S (Σ * Σ)) (S Σ) := Sierpinski.sor.

(** Sierpinski.sor_cont *)
Definition Σor_mp_ok : Cont.t (le (Σ * Σ)) (le Σ)
  (Cov (Σ * Σ)) (Cov Σ) Σor_mp.
Proof.
simpl. unfold Cov. simpl. 
Admitted.

Definition Σor : Σ * Σ ~~> Σ :=
  {| mp := Σor_mp
   ; mp_ok := Σor_mp_ok
  |}.

Class Hausdorff {A : IGT} : Type :=
  { apart : A * A ~~> Σ }.

Arguments Hausdorff A : clear implicits.









Definition point_mp (A : IGT) (f : Subset (S A))
  (fpt : Cont.pt (le A) (Cov A) f)
  : Contprf One A (fun t _ => f t).
Proof.
simpl.
constructor; intros; auto.
- apply FormTop.grefl. pose proof (Cont.pt_here fpt).
  destruct X.
  econstructor. constructor. eassumption.
- apply FormTop.grefl. pose proof (Cont.pt_local fpt X X0). 
  destruct X1.  destruct i. econstructor. eassumption.
  assumption.
- pose proof (Cont.pt_cov fpt X X0). 
  destruct X1. destruct i. 
  apply FormTop.grefl. econstructor; eauto.
Qed.

Definition One_intro_mp {A : IGT} : Contmap A One
  := One.One_intro.

Require Import FunctionalExtensionality.

Definition One_intro_mp_ok {A : IGT} : Contprf A One One_intro_mp.
Proof.
unfold Contprf.
constructor; unfold Cov, One_intro_mp, One.One_intro; simpl; intros.
- apply FormTop.grefl. econstructor. constructor. constructor.
- constructor.
- apply FormTop.grefl. econstructor. constructor; constructor. constructor.
- apply FormTop.grefl. induction X.
  + econstructor. eassumption. constructor.
  + assumption.
  + induction i. eapply X. reflexivity.
Unshelve. constructor. constructor. constructor.
Qed.

Definition One_intro `{A : IGT} : A ~~> One :=
  {| mp := One_intro_mp
   ; mp_ok := One_intro_mp_ok
  |}.

Require Import Spec.Category.
Import Category.

Definition const {Γ A : IGT} (pt : One ~~> A) : Γ ~~> A
  := pt ∘ One_intro.

Definition point (A : IGT) (f : Subset (S A)) (fpt : Cont.pt (le A) (Cov A) f)
  : One ~~> A :=
  {| mp := fun t _ => f t
   ; mp_ok := point_mp A f fpt
  |}.