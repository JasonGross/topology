
%% bare_conf.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[conference]{IEEEtran}
% Some Computer Society conferences also require the compsoc mode option,
% but others use the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
\usepackage[noadjust]{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at: 
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
\usepackage{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics.
%
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/amsmath





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as the IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/pkg/algorithms
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/pkg/algorithmicx




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/array


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a larger sans serif font
% than the serif footnote size font used in traditional IEEE formatting
% and thus the need to invoke different subfig.sty package options depending
% on whether compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/pkg/subfig




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure.
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.
% The latest version and documentation can be found at:
% http://www.ctan.org/pkg/fixltx2e


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/stfloats
% Do not use the stfloats baselinefloat ability as the IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that the IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as the IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/pkg/dblfloatfix




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/url
% Basically, \url{my_url_here}.




% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}



%Ben's stuff
\usepackage{amssymb}
\usepackage{url}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{../tex/mathpartir}
\usepackage{fancyvrb}

\usepackage{amsthm}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corrolary}{Corrolary}
\newtheorem{claim}{Claim}

\definecolor{green}{rgb}{0.0, 0.5, 0.0}
\definecolor{red}{rgb}{0.8, 0.0, 0.0}

\newcommand{\Space}{\mathsf{Space}}
\newcommand{\PLower}{\mathcal{P}_\lozenge}
\newcommand{\Viet}{\mathcal{P}_{\square\lozenge}}
\newcommand{\hookto}{\hookrightarrow}
\newcommand{\Meas}{\mathcal{M}}

\newcommand{\cto}{\to_c}
\newcommand{\R}{\mathbb{R}}
\newcommand{\rat}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\lowerT}[1]{\overrightarrow{#1}}
\newcommand{\cov}{\vartriangleleft}
\newcommand{\Pos}{\mathsf{Pos}}
\newcommand{\Type}{\mathcal{U}}
\newcommand{\Prop}{\mathcal{P}}
\newcommand{\List}[1]{\mathsf{List}\ {#1}}
\newcommand{\map}[2]{\mathsf{map}_{#1}[{#2}]}
\newcommand{\fun}[2]{\lambda {#1}.\  {#2}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\suchthat}{\ |\ }
\newcommand{\concat}{\ensuremath{+\!\!\!\!+\,}}
\newcommand{\Zero}{\varnothing}
\newcommand{\One}{\ast}
\newcommand{\Dist}[1]{\mathcal{M}({#1})}
\newcommand{\Open}[1]{\mathcal{O}({#1})}
\newcommand{\coinflip}{\mathsf{coinflip}}
\newcommand{\Sampler}{\mathsf{Sampler}}
\newcommand{\bool}{\mathbb{B}}
\newcommand{\cons}{::}
\newcommand{\un}[1]{\ \mathrm{#1}}
\newcommand{\irule}[1]{\textsc{#1}}
\newcommand{\wildcard}{\_}
\newcommand{\restrict}[2]{{#1}_{|{#2}}}
\newcommand{\Img}[1]{\text{Im}\left({#1}\right)}
\newcommand{\negate}{\mathsf{negate}}

\newcommand*{\tikzbullet}[2]{%
{
  \setbox0=\hbox{\strut}%
  \begin{tikzpicture}
    \useasboundingbox (-.25em,0) rectangle (.25em,\ht0);
    \filldraw[draw=#1,fill=#2] (0,0.3\ht0) circle[radius=.25em];
  \end{tikzpicture}%
  }
}

\newcommand{\GoSafe}{G}
\newcommand{\StopSafe}{S}
\newcommand{\oinclf}[1]{\iota[{#1}]}
\newcommand{\oincl}[2]{\oinclf{#1} \left({#2}\right)}
\newcommand{\Branch}{\Rightarrow}
\newcommand{\comment}[1]{}
\newcommand{\up}{\mathsf{up}}
\newcommand{\btrue}{\mathsf{true}}
\newcommand{\bfalse}{\mathsf{false}}
\newcommand{\bigsig}[2]{\Sigma{#1}.\ {#2}}
\newcommand{\isthemaxof}[3]{{#1}\text{ is the max of }{#2}\text{ and }{#3}}
\newcommand{\strue}{\mathsf{up}(\mathsf{tt})}
\newcommand{\sfalse}{\bot}
\newcommand{\dirsup}[1]{{\bigvee_{#1}}^{\uparrow}}
\newcommand{\BCover}{\mathsf{BCover}}
\newcommand{\iimg}[1]{#1^*}

\newcommand{\RootFindingCode}{
&\mathsf{root}_f : \{ (a, b) : \R \times \R \suchthat a < b \}
  \\ &\qquad \cto \PLower^+(\One + \{ x : \R \suchthat |f(x)| < \varepsilon \})
\\ &\mathsf{root}_f(\ell) \triangleq \mathsf{case}(\mathsf{HeineBorel}(\ell))
\\ &\begin{cases}
\oincl{\lozenge (\fun{x}{|f(x)| < \varepsilon})}{s} 
  &\Branch \map{\PLower^+}{\mathsf{inr}}(\mathsf{some}(\mathsf{un}\square(s)))
\\ \oincl{\square (\fun{x}{f(x) \neq 0})}{\wildcard}
  &\Branch \{ \mathsf{inl}(\mathsf{tt}) \}
\end{cases}
}

\newcommand{\note}[1]{\textcolor{red}{[[{#1}]]}}
\newcommand{\grammar}[1]{\textcolor{red}{\underline{#1}}}
\newcommand{\ConsiderRemoving}[1]{\textcolor{red}{[Consider removing?: \textcolor{black}{#1}]}}
\newcommand{\FutureWork}[1]{}

\renewcommand{\grammar}[1]{#1}

%Perhaps this is okay?
%\allowdisplaybreaks


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Overlapping Pattern Matching for Programming With Continuous Functions}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Benjamin Sherman, Luke Sciarappa, Michael Carbin, Adam Chlipala}
\IEEEauthorblockA{MIT CSAIL\\
Cambridge, USA\\
\{sherman, mcarbin, adamc\}@csail.mit.edu, lukesci@mit.edu}
}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
In functional programming, pattern matching allows definition of a function by partitioning the input and defining the result in each case. We generalize to programming with topological spaces, where patterns need not represent decidable predicates and also may overlap, allowing potentially nondeterministic behavior in overlapping regions. These overlapping patterns are useful for writing a wide array of computer programs on spaces, such as programs that make approximate computations or decisions based on continuous values or that manipulate ``partial'' datatypes. By using the frameworks of formal topology and (predicative) locale theory, programs may be executed, and indeed we formalized the core result within the predicative fragment of Coq.
\end{abstract}

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle


\section{Introduction}

Today, software routinely manipulates continuous concepts, such as space, time, magnitude, and probability. However, such software usually does so with unsound approximations, such as using floating point rather than real numbers. These approximations can result in errors and also make it very difficult to reason about program behavior.

One solution is just to program with topological spaces themselves, in a semantically faithful manner. Committing to programming with spaces in this manner ensures that all total programs are continuous, which offers computational benefits in addition to facilitating reasoning \cite{lamcra, escardoinfinite, escardo2004, simpson1998lazy}. But doing so introduces its own challenges, and the principles of programming in this way have yet to be explored. This article introduces a programming construct that ought to be useful for programming with spaces: \emph{overlapping pattern matches}.

Consider the following computational task. Suppose we have an arbitrary continuous function $f : \R \cto \R$ and want to determine if it has any roots on the interval $[a,b]$, for $a < b$. In general, \grammar{this} is not decidable \cite{lamcra}, but an approximation is possible: fix a tolerance $\varepsilon > 0$. Then either, or both, of the following statements must hold:
\begin{itemize}
\item There is some $x \in [a, b]$ such that $|f(x)| < \varepsilon$
\item For every $x \in [a, b]$, $f(x) \neq 0$
\end{itemize}
Though each of the above statements is in general undecidable, we can use an overlapping pattern match to define a function that nondeterministically computes that one of the above two statements holds, in the former case \emph{computing} such an $x$ that is ``almost a root.'' The code
\begin{align*}
\RootFindingCode
\end{align*}
accomplishes this task.
The result space allows nondeterministic computation (indicated by $\PLower^+$) of either an $\mathsf{inr}(x)$ that is ``almost a root'' or a value $\mathsf{inl}(\mathsf{tt})$ indicating that there are no roots on the interval.
The notations and auxiliary definitions in this program will be explained over the course of this paper, and we will return to this example to give a more thorough analysis in section \ref{s:bcov:root}.
 
Intuitively, overlapping patterns behave much like traditional pattern matches as in functional programming, but an input that matches several patterns may nondeterministically follow any matching branch.

The syntax of an overlapping pattern match determines a unique behavioral specification, but in order to confirm that a continuous map implements such behavior (and thus, to be able to run it), one must confirm
\begin{enumerate}
\item \emph{Covering}: together, the cases cover the entire input space.
\item \emph{Gluing}: nondeterministic unions (maxima with respect to specialization order) exist for each pair of branches on their overlap.
\end{enumerate}
Formal (constructive) proofs of these properties contribute to the computational behavior of the pattern match.

In the $\mathsf{root}_f$ example, covering is satisfied essentially because either of the two earlier bulleted statements must hold (section \ref{s:bcov:root} provides further detail), and the gluing condition is automatically satisfied since the output space always admits nondeterministic unions.


\subsection{Contributions}
\begin{itemize}
\item
We demonstrate (section \ref{s:examples}), by informal example, the utility of overlapping patterns for a variety of purposes, including
\begin{itemize}
\item (nondeterministic) approximate computation and decision-making (\ref{s:ex:approx})
\item manipulating partial data (\ref{s:ex:partial})
\item ``sheafification'' of constructions (\ref{s:ex:sheaf}).
\end{itemize}

\item Following a more formal review of constructive topology (\ref{s:topology}), we formally characterize the overlapping pattern match construction (\ref{s:patterns}). Section \ref{s:properties} examines properties of overlapping patterns, including cases when the covering and gluing conditions can be fulfilled automatically. 

\item We present a case study of programming with constructive topology and with overlapping patterns (\ref{s:bcover}): we generalize the decidable propositions to \emph{binary covers}, pairs of propositions $(P, Q)$ such that either $P$ or $Q$ holds, but $P$ and $Q$ may overlap. Just as the decidable predicates are closed under conjunction, disjunction, negation, and quantification over finite sets, we show that binary covers support these same operations, with finite sets generalized to compact/overt spaces. \grammar{This} yields a calculus for approximate decision procedures over spaces.

\end{itemize}

\section{Example uses of overlapping pattern matching}
\label{s:examples}

This section presents an informal introduction to programming with spaces and to overlapping patterns, providing examples that demonstrate its usefulness in a variety of situations.

\subsection{Preliminaries}

Here we will fix some notation and define concepts that will be used to explain the more exotic examples later in this section, by starting with a familiar example: we can define functions on coproducts (sums) via pattern matching, just as is possible in any functional programming language:
\begin{align*}
\mathsf{forget\_sign} &: \{ \R \suchthat \cdot < 0 \} + \{ \R \suchthat \cdot > 0 \} \cto \R
\\ \mathsf{forget\_sign}(x) &\triangleq
  \mathsf{case}(x)
  \begin{cases}
  \mathsf{inl}(\ell) \quad &\Branch \quad \oincl{\cdot < 0}{\ell}
  \\ \mathsf{inr}(r) \quad &\Branch \quad \oincl{\cdot > 0}{r}
  \end{cases}.
\end{align*}

The notation $\cdot < 0$ denotes an \emph{open} of $\R$; we write $\cdot < 0 : \Open{\R}$. Informally, an open is an observable property of points in a space. Any space is defined by describing its set of opens together with a system of logical axioms $U \le \bigvee_{i : I} V_i$ (called \emph{open covers}) indicating when an open is covered by a collection of other opens, that is, when $U$ holds of a point, then some $V_i$ must hold of that point as well. Accordingly, open covers can be read as computational rules for refining one's state of knowledge of a point in a space: if one presents a point $x$ known to lie in $U$ with the open cover $U \le \bigvee_{i : I} V_i$, $x$ can \emph{compute} an $i : I$ such that $x$ lies in $V_i$; we call this computation \emph{splitting} a point with an open cover (following Palmgren \cite{palmgren2007}).
The opens of a space, ordered by inclusion, form a lattice; $\top$ denotes its top element, which represents the whole space.

The space $\{ \R \suchthat \cdot < 0 \}$ indicates an open subspace of $\R$, and the continuous map $\oinclf{\cdot < 0} : \{ \R \suchthat \cdot < 0 \} \hookto \R$ is an \emph{open embedding} (or open inclusion), meaning that this map identifies how $\{ \R \suchthat \cdot < 0 \}$ sits inside $\R$ as an open subspace.

For general spaces $A$ and $B$, $\mathsf{inl} : A \hookto A + B$ and $\mathsf{inr} : B \hookto A + B$ are also open embeddings; every pattern must be an open embedding. To confirm that $\mathsf{forget\_sign}$ is well-defined, we must check the covering and gluing conditions. Indeed $\mathsf{inl}$ and $\mathsf{inr}$ together cover the input space, and since their images are disjoint, the gluing condition is satisfied as well.

\subsection{Approximate computation and decision-making}
\label{s:ex:approx}

\emph{Connected} spaces, such as $\R$, cannot be partitioned into disjoint open subspaces. Accordingly, it is impossible to make a nontrivial discrete decision over these spaces; for instance, any function $f : \R \cto \bool$ must be a constant function. Instead, it makes sense to allow decisions to be nondeterministic, which can be accomplished by producing output in the space $\PLower^+(\bool)$ of nondeterministic Boolean values, rather than $\bool$.

Any space $A$ has a space $\PLower^+(A)$ of its nondeterministic values. There is a map $\lozenge : \Open{A} \to \Open{\PLower^+(A)}$ (read ``possibly'') that can be intuitively understood in the following sense: if $U : \Open{A}$ is interpreted as a property of points of $A$, and a point $s : \One \cto \PLower^+(A)$ is interpreted as a subspace of $A$, $\lozenge U : \Open{\PLower^+(A)}$ holds of $s$ if $U$ holds of some point in $s$. For every cover $\top \le \bigvee_{i : I} V_i$ in $A$ there is a cover $\top \le \bigvee_{i : I} \lozenge V_i$ in $\PLower^+(A)$, which can be understood computationally as allowing simulation of some nondeterministic result.

The map $\{ \cdot \} : A \cto \PLower^+(A)$ produces singleton subspaces (deterministic values), and the map $\cdot \cup \cdot : \PLower^+(A) \times \PLower^+(A) \cto \PLower^+(A)$ performs a nondeterministic union.

For any error tolerance $\varepsilon > 0$, we can approximately compare a real number with 0 using the function
\begin{align*}
\mathsf{positive?}_\varepsilon &: \R \cto \PLower^+(\bool)
\\ \mathsf{positive?}_\varepsilon(x) &\triangleq \mathsf{case}(x)
\begin{cases}
\oincl{\cdot > - \varepsilon}{\wildcard} \Branch \{ \mathsf{true} \}
\\ \oincl{\cdot < \varepsilon}{\wildcard} \Branch \{ \mathsf{false} \}
\end{cases}.
\end{align*}
To confirm this definition is well-defined, we check covering (obvious) and gluing: since the output space is a nondeterministic powerspace, there is always a nondeterministic union of branch behaviors. If an input lies in $- \varepsilon < \cdot < \varepsilon$, then the resulting behavior is the union of the behaviors of both branches: $\{ \mathsf{true} \} \cup \{ \mathsf{false} \} : \PLower^+(\bool)$; that is, either decision might be made. Note that determining whether an input satisfies $\cdot > - \varepsilon$ is undecidable (likewise for $\cdot < \varepsilon$).

We can nondeterministically break a real number into an integer and a fractional part in $\{ \R \suchthat -\varepsilon < \cdot < 1 \}$ with
\begin{align*}
\mathsf{int\_frac}_\varepsilon &: \R \cto \PLower^+(\Z \times \{ \R \suchthat -\varepsilon < \cdot < 1 \})
\\ \mathsf{int\_frac}_\varepsilon(x) &\triangleq \mathsf{case}(x)
\begin{cases}
[n : \Z] \quad \mathsf{nplus}_n(y) \Branch \{ (n, y) \},
\end{cases}
\end{align*}
which has a branch for each $n : \Z$, and each open embedding $\mathsf{nplus}_n$ embeds $\{ \R \suchthat -\varepsilon < \cdot < 1 \}$ into $\R$ by adding $n$. In general, cases may be indexed by any set. This pattern match implicitly conflates the set $\Z$ with the space $\Z$ (which is permissible for any discrete space and its underlying set).

Section \ref{s:bcover} describes binary covers, giving many further examples of approximate decision-making using overlapping patterns.

\subsection{Manipulating partial data}
\label{s:ex:partial}

For any space $A$, there is a \emph{lifted space} $A_\bot$, which embeds $A$ via the open embedding $\up : A \hookto A_\bot$ into a larger space that has just one more open, a new $\top$. The new $\top$ includes one additional point $\bot : \One \cto A_\bot$ (where $\One$ is the one-point space), which lies in no additional opens, and thus has nondeterministic unions with any other point of $A_\bot$ \cite{topologyvialogic}.

Spaces with bottom points (such as lifted spaces) are useful for representing spaces of ``partial'' results. Computationally, \emph{any} point may ``behave'' as $\bot$, so splitting a point with an open cover may never provide any useful information. To get useful information from a point in a space with bottom, one should \emph{prove} that the point actually lies in some subspace that excludes the bottom point.

We can write, for instance, a partial Boolean $\mathsf{or}$ operation,
\begin{align*}
\mathsf{or} &: \bool_\bot \times \bool_\bot \cto \bool_\bot
\\ \mathsf{or}(p) &\triangleq \mathsf{case}(p)
\begin{cases}
\up(\btrue), \wildcard &\Branch \up(\btrue)
\\ \wildcard, \up(\btrue) &\Branch \up(\btrue)
\\ \up(\bfalse), \up(\bfalse) &\Branch \up(\bfalse)
\\ \wildcard &\Branch \bot
\end{cases}.
\end{align*}

This example demonstrates that it is possible to pattern match on products as well as to nest patterns. For instance, $\mathsf{up}(\mathsf{true})$ corresponds to the nested pattern
\begin{equation*}
\begin{tikzcd}
\One \arrow[r, hook, "\mathsf{true}"]
& \bool
   \arrow[r, hook, "\mathsf{up}"]
& \bool_\bot
\end{tikzcd}.
\end{equation*}
Since $\bool$ is discrete, its points are open embeddings.

Unlike a short-circuiting ``or'' operation in most programming languages, this $\mathsf{or}$ is strict in neither argument, since
\[ 
\mathsf{or}(\mathsf{up}(\mathsf{true}), \bot) = 
\mathsf{or}(\bot, \mathsf{up}(\mathsf{true})) =
\mathsf{up}(\mathsf{true}).
\]

The final case alone is covering, so it remains to check gluing. Though the final case overlaps with every other case, it always has nondeterministic unions with the other cases when they overlap, since it returns $\bot$. The first and second cases do overlap, but they agree exactly, and other case pairs are disjoint from each other. So $\mathsf{or}$ is well-defined.

Adding a catch-all case $(\wildcard \Branch \bot)$ to a pattern match whose output space has a bottom point ensures that the cases are covering, does not affect the gluing requirement, and does not affect the behavior of a pattern match that is already well-defined. Accordingly, it makes sense to keep track of which spaces $B$ have bottom points, and when a $\mathsf{case}$ expression is written whose output space $B$ has a bottom point, the catch-all case can be added automatically (and implicitly). As a result, any pattern match whose output space has a bottom point is automatically covering.

Other operations on lifted spaces are naturally expressed with overlapping patterns. For instance, any $f : A \cto B$ can be lifted to operate on lifted spaces with the overlapping pattern
\begin{align*}
f_\bot &: A_\bot \cto B_\bot
\\ f_\bot(x) &\triangleq
  \mathsf{case}(x)
  \begin{cases}
  \up(z) &\Branch \up(f(z)),
  \end{cases}
\end{align*}
which forces its argument to compute the result, but if the input is $\bot$, then so is the result. Since there is only one branch that does not return $\bot$, the gluing condition is satisfied. Lifting of spaces forms a monad, whose join operation can be expressed with the pattern match
\begin{align*}
\mathsf{join} &: \left( A_\bot \right)_\bot \cto A_\bot
\\ \mathsf{join}(x) &\triangleq \mathsf{case}(x)
\begin{cases}
\up(\up(y)) &\Branch \up(y).
\end{cases}
\end{align*}

\subsubsection{The Sierp\'inski space}

The Sierp\'inski space $\Sigma$ is fundamental in topology \cite{escardo2004}. It is the space of ``truth values,'' giving an exact correspondence between open sets $U : \Open{A}$ and continuous maps $\chi_U : A \cto \Sigma$. The Sierp\'inski space $\Sigma$ is characterized by homeomorphisms
\[
\Sigma \cong \One_\bot \cong \PLower(\One) ,
\]
where for any space $A$, $\PLower(A) \cong {\PLower^+(A)}_\bot$ is similar to $\PLower^+(A)$ but also has a bottom point, which corresponds to the empty subspace. These homeomorphisms relate $\Sigma$ to previously discussed constructions.

In particular, since $\Sigma \cong \PLower(\One)$, any pattern match that outputs to $\Sigma$ automatically satisfies both the covering and gluing conditions. So any overlapping pattern matches that output to $\Sigma$ are automatically well-defined. The bottom element of $\Sigma$, $\{ \} : \PLower(\One)$, is the ``false'' point of $\Sigma$, while $\up(\mathsf{tt}) : \One_\bot$ or $\{ \mathsf{tt} \} : \PLower(\One)$ is the ``true'' point of $\Sigma$.

Logical ``and'' and ``or'' operations on $\Sigma$ can be neatly represented with overlapping patterns:
\begin{align*}
\mathsf{and} &: \One_\bot \times \One_\bot \cto \One_\bot
\\ \mathsf{and}(p) &\triangleq \mathsf{case}(p)
\begin{cases}
\up(\mathsf{tt}) , \up(\mathsf{tt})
  \quad \Branch \quad \up(\mathsf{tt})
\end{cases}
\displaybreak[0] \\
\mathsf{or} &: \One_\bot \times \One_\bot \cto \One_\bot
\\ \mathsf{or}(p) &\triangleq \mathsf{case}(p)
\begin{cases}
\up(\mathsf{tt}) , \wildcard
  \quad &\Branch \quad \up(\mathsf{tt})
\\  \wildcard , \up(\mathsf{tt})
  \quad &\Branch \quad \up(\mathsf{tt})
\end{cases}
\end{align*}

Viewing $\Sigma$ as $\PLower(\One)$, ``or'' corresponds to union of subspaces and generalizes to $\PLower(A)$ for any space $A$. However, the ``and'' operation corresponds to intersection, which can only be generalized to a discrete space $A$ whose underlying set has decidable equality; intersection is not necessarily possible to compute for general $A$.

\subsubsection{Comparison with Haskell pattern matching}

Pattern matching definitions of the form ${A_1}_\bot \times \ldots \times {A_n}_\bot \to B_\bot$ may resemble pattern matches in Haskell. For instance, the $\mathsf{and}$ operation on the Sierp\'inski space corresponds to the Haskell definition
\begin{Verbatim}[samepage=true]
and :: () -> () -> ()
and () () = ()
\end{Verbatim}
which forces both its arguments whenever the return value is forced. However, the definition of $\mathsf{or}$ has no analogue in Haskell, because the translated prospective Haskell definition
\begin{Verbatim}[samepage=true]
or :: () -> () -> ()
or () _ = ()
or _ () = ()
\end{Verbatim}
has an overlap in the two non-catch-all cases, which is forbidden.
The $\mathsf{or}$ operation is often known as the ``parallel-or'' operation \cite{escardo2004}. It has this name because the points of $\Sigma$ can be interpreted as representing semidecision procedures; the parallel-or of two semidecision procedures halts if and only if either of the component procedures halts, perhaps by interleaving them in a parallel fashion.

Our pattern matching construction allows overlapping patterns, since it requires proof that overlapping patterns indeed are reconcilable on their overlap. The partial Boolean $\mathsf{or}$ also has an overlap  in cases, so it cannot be expressed in Haskell, either.

\subsection{``Sheafification'' of constructions}
\label{s:ex:sheaf}

Overlapping patterns naturally allow ``sheafification'' of constructions. We found \grammar{this} useful, for instance, for defining multiplication on $\R$. We defined the space $\R$ as a metric completion of the set $\rat$ (as in \cite{vickersmetric}). Using a straightforward construction to extend a Lipschitz function over metric sets to their metric completions, we defined a family of Lipschitz functions that compute multiplication where one argument is bounded,
\[
\mathsf{scale}_L : \{ \R \suchthat -L < \cdot < L \} \times \R \cto \R
\]
for $L : \rat^+$. Multiplication on $\R$ is not Lipschitz and so cannot be defined directly with the Lipschitz construction. However, multiplication is \emph{locally} Lipschitz: the family of bounded multiplication functions defined above cover the entire input domain $\R \times \R$, and so it is possible to define multiplication with the overlapping pattern
\begin{align*}
\times &: \R \times \R \cto \R
\\ x \times y &\triangleq
\mathsf{case}(x)
\\
&\begin{cases}
[L : \rat^+] \quad \oincl{-L < \cdot < L}{x'}  \  \Branch \  \mathsf{scale}_L(x', y).
\end{cases}
\end{align*}
The covering condition is clearly satisfied, and the gluing condition is satisfied because any two branches agree exactly on their region of overlap.

Just as the Lipschitz extension construction can be ``sheafified'' to allow extension of locally Lipschitz functions, pattern matching naturally enables ``sheafification'' of constructions more generally.

\section{Review of constructive topology}
\label{s:topology}

To make sense of what it means to program with topological spaces, we briefly review formal topology and locale theory. These ``pointfree'' theories of topology are alternative theories that differ slightly from the classical notions and are better behaved from a programming standpoint.

In classical topology, a space is defined as a set of points together with a lattice of subsets, called open, which define an observational structure on the space. In contrast, in locale theory, a space is defined \emph{just} by giving a lattice of ``opens'' (whose elements are \emph{not} necessarily subsets), and the points of this space are defined in terms of this structure.

Since all topological notions in this article are pointfree, we will coopt terminology from classical topology without fear of confusion. Because we want to \emph{compute} with the mathematical structures, we use the propositions-as-types correspondence \cite{toolbox} to encode all propositions as types, such that everything is formalizable within Martin-L\"of type theory (as well as the predicative fragment of Coq). Let $\Type$ denote the universe of types, where the universe level is left implicit. For instance, we define a poset as a type $S : \Type$ together with a relation $\le : S \to S \to \Type$ that is reflexive and transitive. It is important that $\le$ returns a type, rather than a proposition, so that it can be used computationally.

\begin{definition}
A \emph{space} $A$ is a distributive lattice $\Open{A}$ that has top and bottom elements, $\top$ and $\bot$, respectively, and that has $\Type$-indexed joins such that meets distribute over $\Type$-indexed joins: 
\[
a \wedge \bigvee_{i : I} b_i = \bigvee_{i : I} a \wedge b_i.
\]
\end{definition}

We call the lattice $\Open{A}$ the \emph{opens} of $A$, which describes the observable or ``affirmable'' properties of $A$ \cite{topologyvialogic}. If $U \le \bigvee_{i : I} V_i$, we call the family $(V_i)_{i : I}$ an \emph{open cover} of $U$.

\begin{definition}
A \emph{point} $x$ of a space $A$ is a subset $x \models \cdot : \Open{A} \to \Type$ (read ``$x$ lies in'') such that
\begin{mathpar}
\inferrule*[right=split]
  {x \models U \\ U \le \bigvee_{i : I} V_i}
  {\bigsig{i : I}{x \models V_i}}
\\
\inferrule*[right=meet-0]
  { }
  {x \models \top}
\\
\inferrule*[right=meet-2]
  {x \models U \\ x \models V}
  {x \models U \wedge V}.
\end{mathpar}
\end{definition}

The $\Sigma$ notation in the \irule{split} rule denotes a dependent pair. The \irule{split} rule says that points ``split'' covers and gives a mechanism for computing with points. When a point $x$ that lies in $U$ is presented with an open cover $U \le \bigvee_{i : I} V_i$, it uses the \emph{proof} of the covering relationship to compute some open $V_i$ that $x$ also lies in. The index $i$ is a concrete answer that indicates where the point lies. The \irule{meet} rules ensure consistency of the answers that the \irule{split} rule returns.

\begin{definition}
A \emph{continuous map} $f : A \cto B$ between spaces is a map $\iimg{f} : \Open{B} \to \Open{A}$ that preserves finitary meets and $\Type$-indexed joins.
\end{definition}

Here, $\iimg{f}$ is known as the inverse image map. A continuous map $f : A \to B$ transforms covers on $B$ into covers on $A$. Spaces and continuous maps form a category \textbf{Spc}. The terminal object is the one-point space $\One$, whose open set lattice $\Open{\One}$ is $\Type$ where $U \le V$ is defined as the set of functions from $U$ to $V$. Meets are defined as products, and $\Type$-indexed joins are defined as $\Sigma$-types. Points of a space $A$ can be identified with continuous maps $\One \cto A$, which is frequently convenient.

There is a useful partial order on continuous maps known as \emph{specialization order}, for which we will also use the symbol $\le$. For two maps $f, g : A \cto B$, $f \le g$ if for every $U : \Open{B}$, $\iimg{f}(U) \le \iimg{g}(U)$. Intuitively, if $f \le g$, then an implementation of $g$ could always ``behave'' computationally as an implementation of $f$; $f$ has no more behaviors than $g$ does. Accordingly, specialization order makes good sense of nondeterminism, since any map $f$ can behave just as any map that is smaller than $f$. We say that two maps $f, g : A \cto B$ have a \emph{maximum} if the map
\begin{align*}
\iimg{(f \sqcup g)} &: \Open{B} \to \Open{A}
\\ \iimg{(f \sqcup g)}(U) &\triangleq \iimg{f}(U) \vee \iimg{g}(U)
\end{align*}
preserves binary meets, which implies that it defines a continuous map.

Two spaces $A$ and $B$ are \emph{homeomorphic}, written $A \cong B$, if there are continuous maps $f : A \cto B$ and $g : B \cto A$ such that $g \circ f = \mathsf{id}_A$ as well as $f \circ g = \mathsf{id}_B$.

Given a space $A$ and an open $U : \Open{A}$, we can form the open subspace $\{ A \suchthat U \}$ of $A$ by making $\Open{\{A \suchthat U \}}$ a quotient of $\Open{A}$, identifying opens $P, Q : \Open{A}$ in $\{ A \suchthat U \}$ when $P \wedge U = Q \wedge U$. The quotient still defines a space, since the operation $\cdot \wedge U : \Open{A} \to \Open{A}$ preserves binary meets and all joins.

A map $f : A \cto B$ is an \emph{open embedding} if $A$ is homeomorphic to its image under $f$ in $B$, that is, if there is an open subspace $U : \Open{B}$ and homeomorphism $\tilde{f} : A \cto \{B \suchthat U \}$ such that the following diagram commutes:
\begin{equation*}
\begin{tikzcd}
A \arrow[r, "\tilde{f}", shift left]
   \arrow[r, <-, shift right, swap, "\tilde{f}^{-1}"]
   \arrow[dr,swap,"f", shift right, shift right]
& \{ B \suchthat U \}
   \arrow[d, "\oinclf{U}"]
\\
{} & B
\end{tikzcd}
\end{equation*}
The notation $f : A \hookto B$ indicates that the continuous map $f : A \cto B$ is an open embedding, and the notation $\Img{f}$ indicates the open $U$ of $B$ that $f$ factors through.

Unfortunately, a general construction of product spaces is not possible in \textbf{Spc} (predicatively) \cite{coquand2003}. \grammar{This} motivates the definition of \emph{inductively generated formal spaces} by Coquand et al. \cite{coquand2003}. As a category, the inductively generated formal spaces, \textbf{FSpc}, have products and form a full subcategory of \textbf{Spc}. In particular, \textbf{FSpc} is a cartesian monoidal category, meaning that it admits a restricted $\lambda$-calculus syntax that ``compiles'' to continuous maps \cite{escardo2004}, which this paper uses.
Coquand et al. and Vickers demonstrate inductive generation of all spaces used in this paper \cite{coquand2003, vickersmetric, vickersdoublepowerlocale, SublocFT, vickersconnected}.
These constructions are critical in enabling computation over these spaces.

Since locale theory is generally impredicative, care must be taken with defining the predicative analogue presented here. For instance, in this formalization, the universe of the set of opens of any nontrivial space must be large relative to the universe of sets over which joins are admitted. Palmgren \cite{palmgren2003} offers a more careful treatment of predicativity and universes in formal topology.

The use of a dependent pair in the \irule{split} rule agrees with formal topology as formalized in Martin-L\"of type theory but differs from Maietti and Sambin \cite{whypointfree}, who use an existential quantifier that does not guarantee a computational interpretation.

\comment{
\begin{definition}
An \emph{inductively generated formal space} is a preorder $S$ together with a function 
\[
C : S \to \Sigma (I : \Type).\ I \to (S \to \Type),
\]
called an \emph{axiom set}.
\end{definition}

The preorder $S$ represents a base for the opens of the space. The construction in \cite{coquand2003} generates the ``free'' space $X$ whose base is $S$, with an inclusion of the base $y : S \to \Open{X}$ that satisfies, for each $s : S$, letting $(I, U) = C(s)$, for any $i : I$, 
\begin{mathpar}
\inferrule*
  {}
  {ya \le \bigvee_{b : U_i} yb}
\end{mathpar}
}

\section{Formal definition of overlapping patterns}
\label{s:patterns}

\subsection{General specification of overlapping patterns}
The general syntax for an overlapping pattern match on a term $x : A$ to produce a value in $B$ is of the form
\begin{align*}
f &: A \cto B
\\ f(x) &\triangleq \mathsf{case}(x)
\begin{cases}
[i : I] \quad p_i(x_i) \quad \Branch e_i(x_i)
\end{cases},
\end{align*}
where $i$ ranges over the index set $I : \Type$, each $p_i : A_i \hookto A$ is an open embedding, each $e_i : A_i \cto B$ is a general expression, and each $x_i : A_i$ is a pattern variable binding.\footnote{
Note that a pattern match written on several lines such as
\[
\begin{cases}
[i : I] \quad p_i(x_i) \quad &\Branch e_i(x_i)
\\ [j : I] \quad q_j(y_j) \quad &\Branch h_j(y_j)
\end{cases}
\]
can be rewritten as the single-line pattern match
\[
\begin{cases}
[i : I + J] \quad P_i(x_i) \quad &\Branch E_i(x_i)
\end{cases}
\]
that uses the sum index set $I + J$, where
\begin{align*}
P_{\mathsf{inl}(i)} &= p_i
& E_{\mathsf{inl}(i)} &= e_i
\\ P_{\mathsf{inr}(j)} &= q_j
& E_{\mathsf{inr}(j)} &= h_j.
\end{align*}
}

Such an overlapping pattern match specifies an inverse image map $\iimg{f} : \Open{B} \to \Open{A}$ that acts on opens according to
\[
\iimg{f}(U) = \bigvee_{i : I} \iimg{(e_i \circ \tilde{p}_i^{-1})}(U).
\]
In this definition, we implicitly convert opens of $\{ A \suchthat \Img{p_i} \}$ to opens of $A$ by taking their meets with $\Img{p_i}$.

As expected, $\iimg{f}$'s behavior is the union of the behaviors of all of the branches, as the join represents. For $\iimg{f}$ to define a continuous map, one must confirm that it preserves all joins and finite meets.

We can always transform the pattern match defining $f$ into an equivalent one
\[
f(x) = \mathsf{case}(x)
\begin{cases}
[i : I] \quad \oincl{\Img{p_i}}{x_i} \Branch (e_i \circ \tilde{p}_i^{-1})(x_i)
\end{cases},
\]
where all of the patterns are just open subspaces of the input domain, which one can confirm has the same specification $\iimg{f}$ as above. Since this transformation is possible, for simplicity, it suffices to consider pattern matches of the form
\begin{align}
\label{eq:pattern}
f(x) \triangleq \mathsf{case}(x)
\begin{cases}
[i : I] \quad \oincl{P_i}{x_i} &\Branch e_i(x_i)
\end{cases},
\end{align}
where $P_i : \Open{A}$ and $e_i : \{ A \suchthat P_i \} \cto B$, meaning that $f$ transforms opens according to
\begin{align}
\label{eq:iimg}
\iimg{f}(U) = \bigvee_{i : I} \iimg{e_i}(U).
\end{align}

\subsection{Confirming validity of patterns}

The $\mathsf{case}$ expression above entirely determines the \emph{specification} of the program's behavior as an inverse image map, but we still need to prove two conditions to show that it is valid, which are also then used in the \emph{implementation} of the program. \grammar{That} means that these proofs will affect the \emph{computational} behavior of the program, meaning that different proofs might result in different responses when points are split with open covers. 
\begin{theorem}
\label{pattern}
If the cases cover the input space,
\[
\top \le \bigvee_{i : I} P_i \tag{covering},
\]
and overlapping patterns have nondeterministic unions, i.e., for each $i, j : I$, there is a map $e_{ij} : \{A \suchthat P_i \wedge P_j \} \cto B$ such that
\[
\isthemaxof{ e_{ij} }{ e_i \circ \oinclf{P_j} }{ e_j \circ \oinclf{P_i} }, \tag{gluing}
\]
then $f$ (as defined by equations \ref{eq:pattern}, \ref{eq:iimg})
is a continuous map.
\end{theorem}
\begin{proof}
The map $\iimg{f}$ preserves joins, since all the constituent maps $\iimg{e_i}$ do as well, and since joins commute with each other. Thus, it remains to confirm that $\iimg{f}$ preserves finitary meets.
Since the cases cover the input space, $\iimg{f}$ preserves $\top$:
\[
\iimg{f}(\top) = \bigvee_{i : I} \iimg{e_i}(\top) = \bigvee_{i : I}P_i = \top.
\]
Thus it remains to show that $\iimg{f}$ preserves binary meets.
To confirm that $\iimg{f}$ preserves binary meets, we first note that
\begin{align*}
\iimg{f}(U) \wedge \iimg{f}(V) 
  &= \left(\bigvee_{i : I} \iimg{e_i}(U) \right) \wedge \left( \bigvee_{j: I} \iimg{e_j}(V) \right)
\\ &= \bigvee_{i, j : I} \iimg{e_i}(U) \wedge \iimg{e_j}(V).
\end{align*}
We have $\iimg{f}(U \wedge V) \le \iimg{f}(U) \wedge \iimg{f}(V)$ by
\begin{align*}
\iimg{f}(U \wedge V)
  = \bigvee_{i : I} \iimg{e_i}(U \wedge V)
  &= \bigvee_{i : I} \iimg{e_i}(U) \wedge \iimg{e_i}(V)
  \\ &\le \bigvee_{i, j : I} \iimg{e_i}(U) \wedge \iimg{e_j}(V).
\end{align*}
To prove the opposite inequality, we first note the equivalence
\[
\iimg{f}(U) = \bigvee_{i : I} \iimg{e_i}(U) = \bigvee_{i, j : I} \iimg{e_{ij}}(U),
\]
since $e_{ii} = e_i$ and 
\[
\iimg{e_{ij}}(U) = \left( \iimg{e_i}(U) \vee \iimg{e_j}(U) \right) \wedge \left(P_i \wedge P_j \right).
\]
Then
\begin{align*}
\iimg{f}(U \wedge V)
  = \bigvee_{i, j : I} \iimg{e_{ij}}(U \wedge V)
  &= \bigvee_{i, j : I} \iimg{e_{ij}}(U) \wedge \iimg{e_{ij}}(V)
  \\ &\ge \bigvee_{i, j : I} \iimg{e_i}(U) \wedge \iimg{e_j}(V),
\end{align*}
so in fact $\iimg{f}(U \wedge V) = \iimg{f}(U) \wedge \iimg{f}(V)$, meaning that $\iimg{f}$ preserves binary meets.
\end{proof}

Returning to the general case where any open embeddings are allowed as patterns, the conditions generalize accordingly. We require for the pattern
\[
\begin{cases}
[i : I] \quad p_i(x_i) \quad \Branch e_i(x_i)
\end{cases},
\]
where each $p_i : A_i \hookto A$, that the cases cover the input space,
\[
\top \le \bigvee_{i : I} \Img{p_i},
\]
and that overlapping patterns can be glued, i.e., for each $i, j : I$, there is a map
\[
e_{ij} : A_i \times_A A_j \cto B,
\]
where $A_i \times_A A_j$ is the pullback of $p_i$ and $p_j$, such that 
\[
\isthemaxof{ e_{ij} }{ e_i \circ \theta_{ij}}{ e_j \circ \varphi_{ij}},
\]
where $\theta_{ij} : A_i \times_A A_j \hookto A_i$ and $\varphi_{ij} : A_i \times_A A_j \hookto A_j$ are the expected pullback projections. Using pullback is just a natural way to encode the transformation of the gluing condition, noting the homeomorphism
\[
 \{A \suchthat \Img{p_i} \wedge \Img{p_j} \} \cong A_i \times_A A_j.
\]

Those collections of open embeddings $\left( p_i : A_i \hookto A \right)_{i : I}$ which are considering covering, that is,
\[
\top \le \bigvee_{i : I} \Img{p_i},
\]
form a Grothendieck pretopology called the \emph{open cover topology}.

\subsection{Pattern matching on products}

Given open embeddings $p : U \hookto A$ and $q : V \hookto B$, the parallel embedding $p \otimes q : U \times V \hookto A \times B$ is also an open embedding. \grammar{This} allows us to pattern match through products. 
For instance, we can define
\begin{align*}
 \mathsf{pair}_\bot &: A_\bot \times B_\bot \cto \left( A \times B \right)_\bot
\\ \mathsf{pair}_\bot(p) &\triangleq \mathsf{case}(p)
\begin{cases}
\up(x) , \up(y)
  \quad \Branch \quad \up(x, y)
\end{cases}
\end{align*}
as an overlapping pattern match.

We can use pattern matching on products to allow pattern matching on only part of the input space, passing the rest of the ``context'' through unmodified. (for instance, with multiplication on $\R$ defined in section \ref{s:ex:sheaf}). That is, we want to define a pattern matching function
\begin{align*}
f &: \Gamma \times A \cto B
\\ f(\gamma, x) &\triangleq \mathsf{case}(x)
\begin{cases}
[i : I] \quad p_i(x_i) \quad \Branch e_i(\gamma, x_i)
\end{cases},
\end{align*}
where $p_i : A_i \hookto A$ and $e_i : \Gamma \times A_i \cto B$.
We can reduce this to the existing construction by defining
\begin{align*}
f &: \Gamma \times A \cto B
\\ f(z) &\triangleq \mathsf{case}(z)
\begin{cases}
[i : I] \quad \mathsf{id}_\Gamma(\gamma) , p_i(x_i) \quad \Branch e_i(\gamma, x_i)
\end{cases}.
\end{align*}
This definition is valid so long as $(p_i)_{i : I}$ covers $A$ and each $e_i$ and $e_j$ have a maximum on their overlap, since if $(p_i)_{i : I}$ covers $A$, then $(\mathsf{id}_\Gamma \otimes p_i)_{i : I}$ covers $\Gamma \times A$.


\section{Properties of overlapping patterns}
\label{s:properties}

In general, to prove the validity of an overlapping pattern match, one must prove satisfaction of the covering and gluing conditions. However, in some cases, we can automatically/generically discharge either of these two goals. 

\subsection{Covering automatically: catch-all cases}

When writing a pattern match with an output space $B$ that has a bottom point $\bot_B : B$ (with respect to the specialization order), it is sensible not to require that the cases in a pattern match cover the entire input space, that is, to skip the \emph{covering} condition. We note that for any $\mathsf{case}$ expression
\[
\mathsf{case}(x)
\begin{cases}
[i : I] \quad f_i(x_i) \quad \Branch e_i(x_i)
\end{cases}
\]
that is already valid where the output space $B$ has a bottom point, we can add a catch-all case
\[
\mathsf{case}(x)
\begin{cases}
[i : I] \quad f_i(x_i) \quad &\Branch e_i(x_i)
\\ \wildcard \quad &\Branch \bot_B
\end{cases}
\]
without changing the meaning. Thus it is a sensible default to apply this transformation to \emph{every} pattern match that outputs to a space with a bottom point, before checking the covering and gluing conditions. Then the catch-all case already suffices to cover the whole space, of course, trivially showing that the covering condition holds for such a transformed pattern match. Since $\bot_B$ has maxima with all points of $B$, the additional gluing conditions induced by adding the catch-all case are satisfied automatically.

\subsection{Gluing automatically: nondeterministic powerspaces}

We can also characterize when the output space $B$ ensures that the \emph{gluing} condition is automatically fulfilled. If $B$ is such that any two (generalized) points have a maximum in terms of specialization order, then certainly \grammar{this} is the case.

This property holds for the \emph{positive lower powerspaces}, $\PLower^+(B)$, for any space $B$, also known as Hoare powerlocales. Each point of $\PLower^+(B)$ corresponds to a nonempty subspace of $B$ that has nice computability properties (precisely, \emph{overtness} \cite{vickersdoublepowerlocale}). We will start by describing $\PLower(B)$, which permits a point that represents the empty subspace. 

For any space $B$, the space $\PLower(B)$ is defined such that there is a bijective correspondence between continuous maps $f : A \cto \PLower(B)$ and maps $\iimg{f} : \Open{B} \to \Open{A}$ that preserve all joins but not necessarily meets. There is a map $\lozenge : \Open{B} \to \Open{\PLower(B)}$ (read ``possibly'') which distributes over joins but not necessarily meets. In particular,
\[
\lozenge U \le \bigvee_{i : I} \lozenge V_i
\]
holds in $\Open{\PLower(B)}$ whenever $U \le \bigvee_{i : I} V_i$ in $\Open{B}$. 

Then $\PLower^+(B)$ is defined such that there is a bijective correspondence between continuous maps $f : A \cto \PLower^+(B)$ and maps $\iimg{f} : \Open{B} \to \Open{A}$ that preserve all joins and the nullary meet ($\iimg{f}(\top) = \top$) but not necessarily binary meets. The map of opens $\lozenge : \Open{B} \to \Open{\PLower^+(B)}$ satisfies all of the properties that it does in $\PLower(B)$ as well as satisfying
$\top \le \lozenge \top$. Accordingly, for every cover $\top \le \bigvee_{i : I} V_i$ in $B$ there is a cover $\top \le \bigvee_{i : I} \lozenge V_i$ in $\PLower^+(B)$. Computationally, this fact says that for any observation we can make on points of $B$, we can make that same observation on \emph{some} nondeterministically chosen point within a subspace of $B$ that is represented as a point of $\PLower^+(B)$.

Vickers \cite{vickersdoublepowerlocale} shows how these two powerspace constructions can be achieved predicatively within \textbf{FSpc}. 

We can define the union of subspaces, $
\cup : \PLower^+(A) \times \PLower^+(A) \cto \PLower^+(A)$ by the map
\begin{align*}
\iimg{(\cup)} &: \Open{A} \to \Open{\PLower^+(A) \times \PLower^+(A)}
\\ \iimg{(\cup)}(P) &\triangleq (\lozenge P \times \top) \vee (\top \times \lozenge P),
\end{align*}
where for opens $U$ of $A$ and $V$ of $B$, $U \times V : \Open{A \times B}$ is an open ``rectangle.''
We must confirm $\iimg{(\cup)}$ preserves all joins and $\top$. Clearly $\iimg{(\cup)}$ preserves joins since $\lozenge$ does, and
\[
\iimg{(\cup)}(\top) = (\lozenge \top \times \top) \vee (\top \times \lozenge \top) = \top.
\]
Computationally, we can read $x \cup y$ as a nondeterministic choice between $x$ and $y$.
It is straightforward from the definition of $\cup$ that $\isthemaxof{x \cup y}{x}{y}$ in terms of specialization order, meaning that $x \cup y$ may behave either as $x$ or as $y$ (and it is the \emph{least} such point that can do so). Accordingly, when the output space of a pattern match is of the form $\PLower^+(A)$ for some $A$, the gluing condition is always satisfied.

Note that for any space $A$, $\PLower(A)$ has a bottom point $\{ \} : \One \cto \PLower(A)$, defined by
\begin{align*}
\iimg{\{\}} &: \Open{A} \to \Open{\One}
\\ \iimg{\{ \}}(P) &\triangleq \bot,
\end{align*}
which corresponds to the empty subspace of $A$. Therefore, when the output space is $\PLower(A)$, \emph{both} the covering and gluing conditions are automatically satisfied, so \emph{any} overlapping pattern match that outputs to $\PLower(A)$ is valid.

\subsection{Equational reasoning about evaluation}

Overlapping patterns admit a form of equational reasoning. A function $f : A \cto B$ defined by the pattern match
\[
f(x) \triangleq \mathsf{case}(x)
\begin{cases}
[i : I] \quad p_i(x_i) \quad \Branch \quad e_i(x_i)
\end{cases}
\]
where each $p_i : A_i \hookto A$ and $e_i : A_i \to B$,
when evaluated on a (generalized) point $x : \Gamma \cto A$,
can be described by
\[
(f \circ x)(\gamma) = \mathsf{case}(\gamma)
\begin{cases}
[i : I] \quad q_i(\gamma_i) \quad \Branch \quad e_i(x_i(\gamma_i)),
\end{cases}
\]
where each $q_i$ and $x_i$ come from the pullback diagram
\begin{equation*}
\begin{tikzcd}
A_i \times_A \Gamma \arrow[r, hook, "q_i"]
   \arrow[d, "x_i"]
   \arrow[dr, phantom, "\lrcorner", very near start]
& \Gamma \arrow[d, "x"]
\\ A_i \arrow[r, hook, "p_i"]
& A
\end{tikzcd}.
\end{equation*}

In particular, suppose for each $i : I$, the open
\[
\Img{q_i} : \Open{\Gamma}
\]
is either $\top$ or $\bot$. If $x$ is a global point, meaning $\Gamma \cong \One$, then classically \grammar{this} is the case. Let $I_\top$ and $I_\bot$ represent the indices where the opens are $\top$ and $\bot$, respectively, and for $i : I_\top$, let $x_{A_i} : \Gamma \cto \{ A \suchthat \Img{p_i} \}$ be $x$ with a restricted range. Then for any $U : \Open{B}$,
\begin{align*}
\iimg{f}(U) &= \bigvee_{i : I} \iimg{(e_i \circ x_i \circ \tilde{q}_i^{-1})}(U)
\\ &= \bigvee_{i : I_\top} \iimg{(e_i \circ x_i \circ \tilde{q}_i^{-1})}(U)
\\ &= \bigvee_{i : I_\top} \iimg{(e_i \circ \tilde{p}_i^{-1} \circ x_{A_i})}(U)
\end{align*}

These arguments confirm the intuitive explanation about evaluation of overlapping patterns. It is possible to symbolically reduce a pattern match that scrutinizes a point if it is known which branches the scrutinee may fall into: collect the possible branches, apply them to the point, and the behavior will be the nondeterministic union of those results.

For instance, in section \ref{s:ex:approx}, we found that the partial Boolean $\mathsf{or}$ satisfies
\[
\mathsf{or}(\mathsf{up}(\mathsf{true}), \bot) = \mathsf{up}(\mathsf{true}).
\]
We confirm \grammar{this} by ``pulling back'' the pattern match defining $\mathsf{or}$ on this input to
\begin{align*}
\mathsf{or}(\mathsf{up}(\mathsf{true}), \bot) = \mathsf{case}(\mathsf{tt})
\begin{cases}
\wildcard &\Branch \up(\btrue)
\\ \mathsf{abort}(x) &\Branch \mathsf{abort}(x)
\\ \mathsf{abort}(x) &\Branch \mathsf{abort}(x)
\\ \wildcard &\Branch \bot
\end{cases},
\end{align*}
where for any space $A$, $\mathsf{abort} : \Zero \hookto A$ is the trivial embedding of the empty space $\Zero$. Patterns that match the scrutinee reduce to the embedding $\mathsf{id} : \One \hookto \One$ (the wildcard pattern), and patterns that it misses entirely reduce to $\mathsf{abort}$. We can then collect only the possible branches,
\begin{align*}
\mathsf{or}(\mathsf{up}(\mathsf{true}), \bot) = \mathsf{case}(\mathsf{tt})
\begin{cases}
\wildcard &\Branch \up(\btrue)
\\ \wildcard &\Branch \bot
\end{cases},
\end{align*}
to conclude that $\mathsf{or}(\mathsf{up}(\mathsf{true}), \bot)$ is the join of $\bot$ and $\mathsf{up}(\mathsf{true})$, which is just $\mathsf{up}(\mathsf{true})$.

\subsection{Composition of patterns}

As covering families of open embeddings form a Grothendieck pretopology, homeomorphisms alone are covers, and covers can be composed, which each correspond to constructions involving overlapping patterns.

Any homeomorphism is a cover by itself (``reflexivity''), corresponding to a pattern that may change the ``view'' of data to an isomorphic space (without breaking it apart). For instance, given the homeomorphism $\mathsf{exp} : \R \hookto \{ \R \suchthat \cdot > 0 \}$, we can define multiplication on $\{\R \suchthat \cdot > 0 \}$ using addition on $\R$ with the neat pattern match
\begin{align*}
\mathsf{mult} &: \{\R \suchthat \cdot > 0 \} \times \{\R \suchthat \cdot > 0 \} \cto \{\R \suchthat \cdot > 0 \}
\\ \mathsf{mult}(p) &\triangleq \mathsf{case}(p)
\begin{cases}
\mathsf{exp}(x), \mathsf{exp}(y) &\Branch \mathsf{exp}(x + y)
\end{cases}.
\end{align*}

There is also a notion of composition of covers (``transitivity''), which corresponds to the potential to flatten nested patterns. For instance, the definition
\begin{align*}
f &: A_\bot + B_\bot \cto \left(A + B\right)_\bot
\\ f(x) &\triangleq \mathsf{case}(x)
\begin{cases}
\mathsf{inl}(\ell) &\Branch \mathsf{case}(\ell)
  \begin{cases}
  \up(\ell') \Branch \up(\mathsf{inl}(\ell'))
  \end{cases}
\\
\mathsf{inr}(r) &\Branch \mathsf{case}(r)
  \begin{cases}
  \up(r') \Branch \up(\mathsf{inr}(r'))
  \end{cases}
\end{cases}
\end{align*}
can be flattened into
\begin{align*}
f(x) &\triangleq \mathsf{case}(x)
\begin{cases}
\mathsf{inl}(\up(\ell)) &\Branch \up(\mathsf{inl}(\ell))
\\
\mathsf{inr}(\up(r)) &\Branch \up(\mathsf{inr}(r))
\end{cases}.
\end{align*}

Correctness of the above flattening operation relies on the additional property that flattening commutes with addition of catch-all cases.

\section{Case study: binary covers}
\label{s:bcover}

In this section, we develop a theory of \emph{binary covers}, which are pairs of open sets that cover a given space. These binary covers are useful for computing approximate decisions on spaces (where computing exact decisions might not be possible). This development is intended to serve as a case study for programming with spaces and demonstrates the utility of overlapping pattern matches.

The basic idea is to generalize the notions of exhaustive reasoning from general functional programming, where it is possible to compute whether or not decidable propositions hold. There is a calculus of decidable predicates: they are closed under conjunction, disjunction, and negation, and universal and existential quantification over finite sets yields decidable predicates as well.

We can relax the notion of decidable predicates to binary covers. Whereas a decidable proposition $P$ is one where either $P$ or $\neg P$ holds, a binary cover is a pair of propositions $P$ and $Q$ such that either $P$ or $Q$ holds. In a binary cover, it is possible that $P$ and $Q$ \emph{both} hold, which is of course never the case for $P$ and $\neg P$ in decidable propositions. So every decidable proposition can be interpreted as a binary cover, but not the other way around.

Translating to spatial language, a decidable predicate on a space $A$ is an open $P$ of $A$ that is also closed (i.e., clopen), meaning that there is a disjoint open $\neg P$ such that $\top \le P \vee \neg P$. A binary cover is a pair of opens $P$ and $Q$ that cover the space, i.e., $\top \le P \vee Q$. We will be able to generalize the finite sets, over which quantification of decidable predicates is decidable, to \emph{compact/overt} spaces, where quantification of binary covers over those spaces yields a binary cover.

For instance, $\R$ has no nontrivial decidable predicates since it is connected, but it admits a wealth of binary covers. We described one such family with the $\mathsf{positive}_\varepsilon$ example from section \ref{s:examples}, where the opens $\cdot > - \varepsilon$ and $\cdot < \varepsilon$ form a binary cover of $\R$.

\subsection{The space of binary covers}

We define a space $\BCover$ as an open subspace of $\Sigma \times \Sigma$. Define the open embeddings $\mathsf{Left}', \mathsf{Right}' : \Sigma \hookto \Sigma \times \Sigma$ by 
$\mathsf{Left}'(x) \triangleq (\strue, x)$ and
$\mathsf{Right}'(x) \triangleq (x, \strue)$.
$\BCover$ is then defined as the open subspace
\[
\BCover \triangleq \{ \Sigma \times \Sigma \suchthat \Img{\mathsf{Left}'} \vee \Img{\mathsf{Right}'} \},
\]

Then let $\mathsf{Left}, \mathsf{Right} : \Sigma \hookto \BCover$ be the restrictions of $\mathsf{Left}'$ and $\mathsf{Right}'$ to $\BCover$; they remain open embeddings.

There is a bijective correspondence between continuous maps $f : A \cto \BCover$ and (ordered) pairs of open sets $P, Q : \Open{A}$ such that $\top \le P \vee Q$. Given such an $f$, $P$ and $Q$ are given by $\iimg{f}(\Img{\mathsf{Left}})$ and $\iimg{f}(\Img{\mathsf{Right}})$, respectively. We confirm that
\[
\top \le P \vee Q
\]
by the derivation
\begin{align*}
\top &\le \iimg{f}(\top) 
  \le \iimg{f}(\Img{\mathsf{Left}} \vee \Img{\mathsf{Right}})
 \\ &\le \iimg{f}(\Img{\mathsf{Left}}) \vee \iimg{f}(\Img{\mathsf{Right}}).
\end{align*}

Given a binary cover of $A$, i.e., opens $P$ and $Q$ of $A$ such that $\top \le P \vee Q$, it is likewise possible to construct a continuous map $f: A \cto \BCover$ such that $\iimg{f}(\Img{\mathsf{Left}}) = P$ and $\iimg{f}(\Img{\mathsf{Right}}) = Q$.

The points of $\Sigma$ correspond to types (quotiented by bi-implication), and accordingly the points of $\BCover$ correspond to types $P, Q : \Type$ such that $P + Q$ is inhabited. Classically, there are three of them: $(\strue, \sfalse), (\strue, \strue),$ and $(\sfalse, \strue)$. Let us name these points $\mathsf{L}$, $\mathsf{B}$, and $\mathsf{R}$, respectively (standing for ``$\mathsf{L}$eft,'' ``$\mathsf{B}$oth,'' and ``$\mathsf{R}$ight''). In the scenario where one of the points is $\sfalse$, then the computational behavior of the point is determined: given the nontrivial open cover 
\[
\top \le \Img{\mathsf{Left}} \vee \Img{\mathsf{Right}}
\]
asking which open holds, there is only one possibility. But for the point $\mathsf{B} = (\strue, \strue)$, there are two possibilities: that is, two implementations of the same point $\mathsf{B}$ can behave differently.

The three points of $\BCover$ have the following Hasse diagram for the specialization order:
\begin{center}
\begin{tikzpicture}
    \node (top) at (0,0) {$\mathsf{B}$};
    \node [below left  of=top] (left)  {$\mathsf{L}$};
    \node [below right of=top] (right) {$\mathsf{R}$};

    % Now draw the lines:
    \draw [thick, shorten <=-2pt, shorten >=-2pt] (top) -- (left);
    \draw [thick, shorten <=-2pt, shorten >=-2pt] (top) -- (right);
\end{tikzpicture}
\end{center}
Note that the points of $\BCover$ always have maxima with respect to specialization order, meaning that it is always possible to join points of $\BCover$ together nondeterministically.

We can arbitrarily think of $\mathsf{Left}$ as ``true'' and $\mathsf{Right}$ as ``false,'' which leads to a notion of order of binary covers in terms of degree of truth, where for $f, g : \Gamma \cto \BCover$, we say $f \leqq g$ if both of the following hold:
\begin{align*} \iimg{f}(\Img{\mathsf{Left}}) &\le \iimg{g}(\Img{\mathsf{Left}})
\\ \iimg{g}(\Img{\mathsf{Right}}) &\le \iimg{f}(\Img{\mathsf{Right}}).
\end{align*}
Then binary covers form a De Morgan algebra with respect to this order; the corresponding conjunction, disjunction, and negation on $\BCover$ are continuous maps:
\begin{align*}
\cdot \wedge \cdot &: \BCover \times \BCover \cto \BCover
\\ x \wedge y &\triangleq \mathsf{case}(x, y)
\begin{cases}
\mathsf{Left}(\wildcard), \mathsf{Left}(\wildcard)
 \quad &\Branch \quad
 \mathsf{L}
\\
\mathsf{Right}(\wildcard), \wildcard
 \quad &\Branch \quad
 \mathsf{R}
\\
\wildcard, \mathsf{Right}(\wildcard)
 \quad &\Branch \quad
 \mathsf{R}
\end{cases}
\displaybreak[0] \\
\cdot \vee \cdot &: \BCover \times \BCover \cto \BCover
\\ x \vee y &\triangleq \mathsf{case}(x, y)
\begin{cases}
\mathsf{Left}(\wildcard), \wildcard
 \quad &\Branch \quad
 \mathsf{L}
\\
\wildcard, \mathsf{Left}(\wildcard)
 \quad &\Branch \quad
 \mathsf{L}
\\
 \mathsf{Right}(\wildcard), \mathsf{Right}(\wildcard)
 \quad &\Branch \quad
 \mathsf{R}
\end{cases}
\displaybreak[0] \\
\neg &: \BCover \cto \BCover
\\ \neg x &\triangleq \mathsf{case}(x)
\begin{cases}
\mathsf{Left}(\wildcard)
 \quad &\Branch \quad
 \mathsf{R}
\\
\mathsf{Right}(\wildcard)
 \quad &\Branch \quad
 \mathsf{L}
\end{cases}.
\end{align*}

We confirm by inspection that the patterns in the definitions of conjunction and disjunction are indeed covering.
Since the output space is $\BCover$, where any two points have maxima, the gluing condition is trivially satisfied.

One can confirm that the definitions of conjunction, disjunction, and negation indeed compute meets, joins, and De Morgan involution with respect to the $\leqq$ ordering.

\subsection{Alternative understandings of binary covers}

There are several other interpretations of binary covers that help explain why the two opens in a binary cover get ``opposite'' treatments in the definitions of conjunction and disjunction. Rather than thinking of a binary cover of $A$ as two opens $P, Q : \Open{A}$ such that (informally) $A \subseteq P \cup Q$, we can instead think of it as an open set $P$ and a \emph{closed} set $\overline{Q}$ which is the ``set-theoretic'' complement of $Q$, since the complement of an open set is closed. Then the fact that $(P, Q)$ is a binary cover means that $\overline{Q} \subseteq P$. Then conjunction computes intersections of the open and closed subspaces, while disjunction computes unions.
For instance, one can find the union of two closed sets by taking their complement to produce two open sets, taking the intersection of that, and then taking the complement to return to a closed set. Since we are simply ``encoding'' closed sets with their open complements, computing the ``union'' of closed subspaces just corresponds to taking an intersection of their open representatives.

\grammar{This} elicits the view of binary covers as ``approximate'' predicates, sandwiching a closed subspace inside an open one, with wiggle room for points in between. Any points in $\overline{Q}$ (and thus also $P$) will definitely compute to $\mathsf{Left}$, while any points outside of $P$ (and thus also outside $\overline{Q}$) will definitely compute to $\mathsf{Right}$, while in-between points, which are in $P$ but not $\overline{Q}$, are allowed to compute either way.

Finally, note that there is a homeomorphism $\BCover \cong \PLower^+(\bool)$ given by
\begin{align*}
\mathsf{to} &: \BCover \cto \PLower^+(\bool)
\\ \mathsf{to}(x) &\triangleq
  \mathsf{case}(x)
  \begin{cases}
\mathsf{Left}(\wildcard)
 \quad &\Branch \quad
 \{ \btrue \}
\\
\mathsf{Right}(\wildcard)
 \quad &\Branch \quad
 \{ \bfalse \}
  \end{cases}
\displaybreak[0] \\
\mathsf{from} &: \PLower^+(\bool) \cto \BCover
\\ \mathsf{from}(s) &\triangleq
  \mathsf{case}(s)
  \begin{cases}
 \oincl{\lozenge(\cdot = \btrue)}{\wildcard}
 \quad &\Branch \quad
 \mathsf{L}
\\
 \oincl{\lozenge(\cdot = \bfalse)}{\wildcard}
 \quad &\Branch \quad
 \mathsf{R}
  \end{cases},
\end{align*}
which gives another understanding of binary covers, as representing nondeterministic truth values in Boolean logic. The logical operations defined for binary covers seem quite appropriate when interpreted by the homeomorphism above. For instance, the conjunction operation on Boolean values,
$\&\& : \bool \times \bool \cto \bool$, can be lifted to a function of type $\PLower^+(\bool) \times \PLower^+(\bool) \cto \PLower^+(\bool)$ which applies $\&\&$ to its nondeterministic input possibilities and collects all the possible results. This lifted $\&\&$ operation, when translated by the above homeomorphism to $\BCover$, is identical to the $\wedge$ operation on $\BCover$s. \grammar{This} applies similarly to the other logical connectives that were defined on $\BCover$s.

Viewing the definitions in this manner easily confirms that the logical connectives defined for $\BCover$ give it the structure of a De Morgan algebra.
The specialization order on $\BCover$ corresponds to subset inclusion on $\PLower^+(\bool)$.

\subsection{Quantification over compact/overt spaces}

In this section, ``finite'' shall always mean Kuratowski-finite \cite{johnstonetopos}.

When working with sets, if a predicate $P$ on a set $A$ is decidable and if $A$ is finite, then $\forall a : A.\ P(a)$ and $\exists a : A.\ P(a)$ are decidable as well. The analog of the finite sets in \textbf{Spc} are the compact/overt spaces.

For any space $A$, there is in fact a space $\Viet(A)$, called the \emph{Vietoris powerspace}, whose points are compact/overt subspaces of $A$. Vickers describes the construction in detail \cite{vickersconnected, vickersdoublepowerlocale}, but we summarize the salient characteristics. This space is a subspace of $\PLower(A)$, having in addition to the ``possibility'' modality $\lozenge : \Open{A} \to \Open{\Viet(A)}$ a ``necessity'' modality $\square : \Open{A} \to \Open{\Viet(A)}$ that distributes over meets and directed joins. Furthermore, for any opens $P, Q : \Open{A}$, the following laws hold:
\begin{align}
\label{boxdiamond}
\square (P \vee Q) &\le \square P \vee \lozenge Q
\\  \square P \wedge \lozenge Q &\le \lozenge (P \wedge Q).
\end{align}
Like the lower powerspaces, there is the ``positive'' subspace $\Viet^+(A)$ of $\Viet(A)$ that additionally satisfies $\top \le \lozenge \top$ and $\square \bot \le \bot$.

These properties allow us to quantify over compact/overt spaces. Suppose we have a binary cover $f : A \cto \BCover$ over a compact/overt space $A$. We define its universal quantification
\begin{align*}
\forall_{[\cdot]} f &: \Viet(A) \cto \BCover
\\ \forall_s f &\triangleq \mathsf{case}(s)
\begin{cases}
\oincl{\square \left( \iimg{f}(\Img{\mathsf{Left}}) \right) }{\wildcard} &\Branch \mathsf{L}
\\ \oincl{\lozenge \left( \iimg{f}(\Img{\mathsf{Right}}) \right)}{\wildcard} &\Branch \mathsf{R}
\end{cases}.
\end{align*}
We can confirm this pattern match is covering, i.e.,
\[
\top \le \square \iimg{f}(\Img{\mathsf{Left}}) \vee \lozenge \iimg{f}(\Img{\mathsf{Right}}),
\]
with the derivation
\begin{align*}
\top 
  &\le \square (\top_A) \tag{$\square$ preserves meets}
\\ &\le \square (\iimg{f}(\top_\BCover)) \tag{$\iimg{f}$ preserves $\top$}
\\ &\le \square (\iimg{f}(\Img{\mathsf{Left}} \vee \Img{\mathsf{Right}}))
\\ &\le \square(\iimg{f}(\Img{\mathsf{Left}}) \vee \iimg{f}(\Img{\mathsf{Right}}))  \tag{$\iimg{f}$ preserves joins}
\\ &\le \square (\iimg{f}(\Img{\mathsf{Left}})) \vee \lozenge (\iimg{f}(\Img{\mathsf{Right}})) \tag{law \ref{boxdiamond}}.
\end{align*}

We can define $\exists_{[\cdot]} f : \Viet(A) \cto \BCover$ by composing $\forall_{[\cdot]} f$ with negation of binary covers.

These constructions are not as general as they could be; in fact, with little additional difficulty it is possible (and useful) to thread through an arbitrary context $\Gamma$. That is, it is possible to quantify a binary cover $f : \Gamma \times A \cto \BCover$ of $A$ in a context $\Gamma$ to a map $\forall_{[\cdot]}f : \Gamma \times \Viet(A) \cto \BCover$ in the same context. The constructions that allow threading through a context admit a neater representation in the gros topos $\mathcal{E}$ of sheaves over spaces with the open cover topology, since $\mathcal{E}$ has higher-order functions. In this setting, one would have the generic operations 
\[
\forall_{[\cdot]}, \exists_{[\cdot]} : \Viet(A) \to (A \to \BCover) \to \BCover
\]
for any space $A$.

Compact/overt spaces form a convenient class of spaces over which exhaustive reasoning is possible. The continuous image of a compact/overt space is compact/overt (similar to the fact that the image of a finite set under any map is finite). Like finite subsets, compact/overt subspaces are closed under finitary union, witnessed by a construction
\[
\cup : \Viet(A) \times \Viet(A) \cto \Viet(A),
\]
but not necessarily intersection. Naturally, a finite set viewed as a discrete space is compact/overt.

\subsection{Binary covers on $\R$}

For the real numbers, there is a construction
\begin{align*}
\mathsf{HeineBorel} &: \{ (a, b) : \R \times \R \suchthat a < b \} \cto \Viet^+(\R)
\end{align*}
that demonstrates for endpoints $a, b$ that the closed interval from $a$ to $b$ is compact/overt and inhabited. Its name indicates that it is a constructive analogue of the Heine-Borel theorem \cite{vickersmetric2}. The notation in the domain is syntactic sugar for $\{ \R \times \R \suchthat \fun{(a,b)}{a < b} \}$, where the lambda notation describes opens via their correspondence with $\Sigma$-valued continuous maps.

We can define binary covers that give approximate order comparisons on $\R$ by defining, for each $\varepsilon : \rat^+$,
\begin{align*}
[ \cdot < \cdot ]_\varepsilon &: \R \times \R \cto \BCover
\\ [x < y]_\varepsilon &\triangleq \mathsf{case}(x, y)
\begin{cases}
\oincl{\fun{(x, y)}{x < y}}{\wildcard} &\Branch \mathsf{L}
\\ \oincl{\fun{(x, y)}{x > y - \varepsilon}}{\wildcard} &\Branch \mathsf{R}.
\end{cases}
\end{align*}

We can use \grammar{this} to query whether an arbitrary continuous map $f : \R \cto \R$ has no points that are close to being roots on an arbitrary closed interval, with the binary cover
\begin{align*}
\mathsf{no\_roots}_{\varepsilon} &: \{ (a, b) : \R \suchthat a < b\} \cto \BCover
\\ \mathsf{no\_roots}_\varepsilon(s) &\triangleq
  \forall_{\mathsf{HeineBorel}(s)}(\fun{x}{[ 0 < |f(x)| ]_\varepsilon}).
\end{align*}
If we observe $\mathsf{Left}$ of the result on input $(a, b)$, then indeed $f$ has no roots on $[a, b]$, while if we observe $\mathsf{Right}$ of the result, then there is some $x \in [a, b]$ such that $|f(x)| < \varepsilon$.

Perhaps we have two maps $f, g : \R \times \R \cto \R$ and wish to confirm, for some compact/overt space $s : \Viet(\R)$ that there is some $x \in [0,1]$ such that for every $y \in s$, $f(x, y)$ is positive while $g(x,y)$ is negative. Then
\begin{align*}
\mathsf{apart}_{\varepsilon} &: \Viet(\R) \cto \BCover
\\ \mathsf{apart}_\varepsilon(s) &\triangleq
  \exists_{[0,1]}(\fun{x}{\forall_{s}(\fun{y}{[ 0 < f(x, y) ]_\varepsilon \wedge [g(x, y) < 0]_\varepsilon})})
\end{align*}
approximately decides \grammar{this}, where $[0,1]$ is used as shorthand for $\mathsf{HeineBorel}(0,1)$.
Like the previous query, this one has only false negatives (and its negation has only false positives). If we observe $\mathsf{Left}$, then it is certainly true, while if we observe $\mathsf{Right}$, then for every $x \in [0,1]$ there is a $y \in [0,1]$ such that either $f(x, y) < \varepsilon$ or $g(x, y) > -\varepsilon$.

The nesting of quantifiers in $\mathsf{apart}_\varepsilon$ make critical use of the quantifier constructions that allow a context $\Gamma$ to be threaded through. For instance, the innermost continuous map of $\mathsf{apart}_\varepsilon$ is a map $\R \times \R \cto \BCover$, where the left $\R$ serves as a context while the right one is quantified over.

\subsection{Approximate root-finding}
\label{s:bcov:root}

Recall the approximate root-finding program from the introduction,
\begin{align*}
\RootFindingCode.
\end{align*}

While previous parts of the paper explain much of this code, it remains to prove that the cases cover, and to explain the expressions in the first branch.

To prove covering, we first observe that  $(\fun{x}{|f(x)| < \varepsilon})$ and $(\fun{x}{f(x) \ne 0})$ form a binary cover of $\R$, since $- \varepsilon < \cdot < \varepsilon$ and $\cdot \neq 0$ form a binary cover of $\R$, and we obtain the former from the latter by precomposing with $f$. Given that these form a binary cover, the covering condition holds by the same derivation that showed that the cases were covering in the definition of $\forall_{[\cdot]}f$.

The expressions in the first branch,
\begin{equation*}
\begin{tikzcd}
\{ \Viet^+(\R) \suchthat \lozenge(\fun{x}{|f(x)| < \varepsilon}) \}
 \arrow[d, tail, "\mathsf{un}\square"]
\\ 
\{ \PLower^+(\R) \suchthat \lozenge(\fun{x}{|f(x)| < \varepsilon}) \}
 \arrow[d, two heads, "\mathsf{some}"]
\\ 
\PLower^+(\{x : \R \suchthat |f(x)| < \varepsilon \})
  \arrow[d, tail, "\mathsf{map}_{\PLower^+}{[\mathsf{inr}]}"]
\\
\PLower^+(\One + \{x : \R \suchthat |f(x)| < \varepsilon \})
\end{tikzcd},
\end{equation*}
shape the useful computational information that is received by falling into the first branch into a form that matches the output type. The map $\mathsf{un}\square$ performs a subset inclusion of the Vietoris powerspace into the lower powerspace, and $\mathsf{some}$ produces a nondeterministic $\{x : \R \suchthat |f(x)| < \varepsilon \}$ from a nondeterministic $\R$ that possibly lies in that subspace. Finally, $\mathsf{map}_{\PLower^+}[\mathsf{inr}]$ is possible because $\PLower^+$ is functorial.

\section{Related work}

\subsection{Alternative theories of constructive topology}

Synthetic topology gives an alternative computable interpretation of topology that differs subtly from formal topology and locale theory \cite{escardo2004, lesnik}. Synthetic topology gives an alternative intuition about overlapping patterns. In this understanding, data types from a (functional) programming language serve as spaces, and open sets are semidecidable predicates that take values of some type as arguments; for points in the open set, the semidecider must halt, whereas for points in the closed complement, the semidecider should not halt.

In this case, an open cover $U \le \bigvee_{i : I} V_i$ means that whenever $U$ halts, then some semidecider $V_i$ also halts.

This interpretation is limited to (classically) spatial locales (locales that also make sense as classical topological spaces) and covers indexed by recursively enumerable sets. But it gives an alternative computational interpretation of overlapping pattern matching: to run a pattern match, run the semideciders for each case in the pattern match \emph{concurrently}. Since the cases must cover the entire space, the semidecider for one case will eventually halt and at that point proceed into the branch corresponding to that case. However, implementing overlapping patterns naively with this computational interpretation does not seem particularly efficient.

\subsection{Pattern matching}

We are unaware of any other notion of pattern matching for functional programming that permits patterns where determining membership is undecidable (without jeopardizing totality).

Coquand \cite{coquand1992} gives a topologically motivated explanation of pattern matching for dependently typed functional programming, describing patterns as (disjoint) partitions of a space.

Dijkstra \cite{dijkstra} introduces ``guarded commands,'' a language construct for imperative programming languages, where a branch can be chosen nondeterministically from a list of statements each guarded by a Boolean expression.

\subsection{Binary covers}

Some of the modified Boolean spaces give topological interpretations of well-known fuzzy logics: $\bool_\bot$ corresponds to Kleene's three-valued logic \cite{kleenemetamathematics}, $\BCover \cong \PLower^+(\bool)$ to Priest's logic of paradox \cite{priest}, and $\PLower(\bool)$ to Dunn/Belnap's four-valued logic \cite{sep-logic-manyvalued}.

dReal is a tool that allows computation of approximate truth values over the real numbers \cite{dReal}, allowing order comparisons and bounded quantifiers. The calculus of binary covers presented here, when restricted to $\R$, provides similar computational abilities but with a different foundational framework. In a sense, \grammar{it} shows how it is possible to generalize the theory behind dReal to spaces other than $\R$.

\section{Discussion and conclusion}

We defined predicative locales and formal topologies in the Coq proof assistant and implemented the core pattern-matching construction (theorem \ref{pattern}). We also defined a function that, given any point $x$ of a space $A$ and any open cover $\top \le \bigvee_{i : I} U_i$ of $A$, returns an index $i : I$ such that $x \models U_i$. Executing this function allows computation of results obtained by running continuous maps. The source code is available at \url{http://github.com/bmsherman/overlapping-patterns/}.

The programs described in this paper conceivably support reasonably efficient implementations, thanks to their use of formal topology and (predicative) locale theory. Formal proofs of the validity of continuous maps defined by their inverse image maps not only confirm correctness but also provide computational content.

Overlapping pattern matches seem useful for a variety of purposes but in particular highlight the  importance of nondeterminism in constructing programs that manipulate spaces. The approximate root-finding procedure in the introduction and the case study of binary covers demonstrate useful nondeterministic programs that can be constructed with overlapping patterns.


\FutureWork{A possible direction of future work would be to extend overlapping patterns to the gros topos $\mathcal{E}$ over \textbf{FSpc} with the previously described open cover topology. For instance, we might want to have an overlapping pattern match that nondeterministically returns a \emph{function}, rather than simply a point of a space. Since \textbf{Spc} and \textbf{FSpc} lack exponentials in general, making sense of \grammar{this} would require extending the constructs defined here to $\mathcal{E}$.}


% conference papers do not normally have an appendix


% use section* for acknowledgment
%\section*{Acknowledgment}
%The authors would like to thank...





% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\bibliographystyle{IEEEtran}
\bibliography{LICS}




% that's all folks
\end{document}


