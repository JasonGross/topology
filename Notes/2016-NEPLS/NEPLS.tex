\documentclass[14pt]{beamer} 
\usetheme{default}

\usepackage{import}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes, arrows.meta}

\usepackage[absolute, overlay]{textpos}

\usepackage{pgfplots}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{../tex/mathpartir}

%\setbeamercovered{transparent}
\definecolor{bgcol}{rgb}{0.8, 0.8, 0.8}
\setbeamercolor{bgcolor}{fg=black,bg=bgcol}

\definecolor{green}{rgb}{0.0, 0.5, 0.0}
\definecolor{red}{rgb}{0.8, 0.0, 0.0}

\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Space}{\mathsf{Space}}
\newcommand{\Open}{\mathsf{Open}}
\newcommand{\PLower}{\mathcal{P}_\lozenge}
\newcommand{\PUpper}{\mathcal{P}_\square}
\newcommand{\Prob}{\mathcal{R}}
\newcommand{\State}{\mathsf{State}}

\newcommand{\cov}{\vartriangleleft}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\suchthat}{\ |\ }
\newcommand{\List}[1]{\mathsf{list}\ {#1}}
\newcommand{\rat}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\bool}{\mathbb{B}}
\newcommand{\Prop}{\mathbb{P}}
\newcommand{\Dist}[1]{\mathcal{P}({#1})}
\newcommand{\fun}[2]{\lambda\ {#1}\Rightarrow{#2}}
\newcommand{\ret}[1]{\mathsf{ret}_{#1}}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt,thick] (char) {#1};}}
            
\newcommand{\dirsup}{\mathop{\setlength{\unitlength}{.7em}\raisebox{-.2em}%
    {\begin{picture}(1,1.5)\put(.5,0){\line(-1,3){.48}}
    \put(.5,0){\vector(1,3){.5}}\end{picture}}}} 
            
\newcommand*{\tikzbullet}[2]{%
  \setbox0=\hbox{\strut}%
  \begin{tikzpicture}
    \useasboundingbox (-.25em,0) rectangle (.25em,\ht0);
    \filldraw[draw=#1,fill=#2] (0,0.3\ht0) circle[radius=.25em];
  \end{tikzpicture}%
}

\newcommand{\SafeToGo}{\tikzbullet{green}{green}}
\newcommand{\SafeToStop}{\tikzbullet{red}{red}}

\title{Programming with continuous spaces}
\author{\textbf{Ben Sherman}, Luke Sciarappa, Michael Carbin, Adam Chlipala
\\ \small MIT}
\date{October 7, 2016}

\setbeamertemplate{footline}{%
  \raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[10pt]{\scriptsize\insertframenumber}}}}
\setbeamertemplate{navigation symbols}{}
%\setbeamertemplate{headline}
%{\vspace{0.03em}
%\begin{beamercolorbox}[wd=\paperwidth,ht=4ex,dp=1ex,center]{bgcolor}
% \small \insertshorttitle
%  \end{beamercolorbox}
%}
\begin{document}

\maketitle

\begin{frame}
\begin{center}
\includegraphics[width=0.6\textwidth]{images/autonomous-car.jpg}
\\
\includegraphics[width=0.6\textwidth]{images/drone.jpg}
\end{center}
\end{frame}

\note{
\small
Software is increasingly applied to safety-critical domains which involve computing with continuous values, such as space, time, probability, and quantity. Cyber-physical systems such as autonomous cars, drones, and rockets must interact with the continuous world, and software errors can be catastrophic.

In domains where software correctness is paramount, construction of formal proofs has been successful. But there are many additional complications for software dealing with continuous values. Definitions of correctness are not so straightforward, and often requiring reasoning about either probabilistic or worst-case uncertainty. Additionally, computations used, such as floating point, aren't mathematically sound.
}

\begin{frame}{Patriot missile failure (1991)}

\begin{itemize}
\item A missile missed its target
\bigskip
\item Cause: numerical rounding error
\bigskip
\item Would like to prove: the missile hits its target with high probability
\end{itemize}

\end{frame}

\begin{frame}{Ariane 5 rocket explosion (1996)}

\begin{itemize}
\item Rocket's guidance system failed
\bigskip
\item Cause: numerical overflow
\bigskip
\item Would like to prove: guidance system's state estimate is close to actual rocket state with high probability
\end{itemize}
\end{frame}

\begin{frame}{Aircraft collision avoidance}
\begin{center}
\includegraphics[width=0.8\textwidth]{images/airplane.jpg}
\end{center}

Detect aircraft which may be on track to collide, and decide on avoidance maneuvers
\end{frame}

\begin{frame}
\begin{center}
\huge Challenge: gap between the \textbf{code} and the \textbf{math}
\end{center}

\bigskip
\pause 
\begin{itemize}
  \item Overflow, rounding errors
  \item Mathematical identities don't actually hold
  \item Proofs about models (e.g., KeYmaera) invalid
  \item Probabilistic semantics are difficult/unclear
\end{itemize}
\end{frame}

\begin{frame}
\begin{center}
\huge Just program literally with continuous spaces!
\end{center}

\bigskip
\pause

\begin{itemize}
\item What does this mean?
\item How to write programs this way?
\end{itemize}
\end{frame}

\begin{frame}{PL for continuous spaces}

\begin{center}
\Large
\begin{align*}
\text{types} &\triangleq \text{spaces}
\\
\text{values} &\triangleq \text{points}
\\
\text{functions} &\triangleq \text{continuous maps}
\end{align*}
\end{center}
\end{frame}

\begin{frame}{$\nat^\infty$: How long does my program run?}
\small
Variables:
\begin{mathpar}
\inferrule{n : \nat}{\mathsf{exactly}(n) : \Open(\nat^\infty)}

\inferrule{n : \nat}{\mathsf{at\_least}(n) : \Open(\nat^\infty)}
\end{mathpar}

Axioms:
\begin{mathpar}
\inferrule{}{\mathsf{at\_least}(n) \vdash \mathsf{exactly}(n) \vee \mathsf{at\_least}(n + 1)}

\inferrule{k \le n}{\mathsf{exactly}(n) \vdash \mathsf{at\_least}(k)}

\inferrule{k \le n}{\mathsf{at\_least}(n) \vdash \mathsf{at\_least}(k)}
\end{mathpar}

\end{frame}

\begin{frame}{Running points of $\nat^\infty$}
\[
\top \vdash \mathsf{exactly}(0) \vee \mathsf{exactly}(1) \vee \mathsf{at\_least}(2)
\]

\pause

\[
\overline{1} \models \mathsf{exactly}(1)
\]

\pause

\[
\overline{5} \models \mathsf{at\_least}(2)
\]

\pause

\[
\infty \models \mathsf{at\_least}(2)
\]

\end{frame}

\begin{frame}{Running points}
\begin{center}
\only<1>{\resizebox{0.7\textwidth}{!}{\import{../Figures/Cover/output/}{step1.pdf_tex}}}
\only<2>{\resizebox{0.7\textwidth}{!}{\import{../Figures/Cover/output/}{step2.pdf_tex}}}
\only<3>{\resizebox{0.7\textwidth}{!}{\import{../Figures/Cover/output/}{step3.pdf_tex}}}
\end{center}
\end{frame}

\begin{frame}{Running points (formally)}
\begin{align*}
&A : \Space \\
& I : \Type \\
&i : I \vdash P_i : \Open(A) \\
&x : \mathsf{Pt}(A)
\end{align*}

\bigskip

\begin{mathpar}
\inferrule* [right=]
  {\quad \top \vdash_A \bigvee_{i : I} P_i}
  {\exists i : I, x \models P_i}
\end{mathpar}
\end{frame}

\begin{frame}{$\R$}
Variables:
\begin{mathpar}
\inferrule{p, q : \rat}
 {p < \cdot < q : \Open(\R)}
\end{mathpar}

Axioms: next slide
\end{frame}

\begin{frame}
\small
\begin{figure}
\begin{center}
\frame{\begin{subfigure}[t]{\textwidth}
\begin{center}
 \begin{tikzpicture}
 \node[draw=white] (spacing) at (0, 0.22) {}; %for spacing purposes only
 \draw [<->, thick] (-2, 0) -- (2, 0);
 \draw [(-), ultra thick, blue] (-1, -0.2) -- (1, -0.2);
 \draw [(-), ultra thick, red] (-1.5, 0.2) -- (1.5, 0.2);
 \end{tikzpicture}
 \end{center}
\begin{mathpar}
\inferrule* [right=widen]
  {p' \le p < q \le q' }
  {p < \cdot < q \vdash p' < \cdot < q'}
\end{mathpar}
\end{subfigure}}

\vspace{1em}

\frame{\begin{subfigure}[t]{\textwidth}
\begin{center}
 \begin{tikzpicture}
\node[draw=white] (spacing) at (0, 0.42) {}; %for spacing purposes only
 \draw [<->, thick] (-2, 0) -- (2, 0);
 \draw [(-), ultra thick, blue] (-1, -0.2) -- (1, -0.2);
 \draw [(-), ultra thick, red] (-1.5, 0.2) -- (0.5, 0.2);
  \draw [(-), ultra thick, red] (-0.5, 0.4) -- (1.5, 0.4);
 \end{tikzpicture}
 \end{center}
\begin{mathpar}
\inferrule* [right=split]
  {r < p < u < s < q < v}
  {p < \cdot < q \vdash r < \cdot < s \ \vee\  u < \cdot < v }
\end{mathpar}
\end{subfigure}}

\vspace{1em}

\frame{\begin{subfigure}[t]{\textwidth}
\begin{center}
 \begin{tikzpicture}
 \draw [<->, thick] (-2, 0) -- (2, 0);
 \draw [(-), ultra thick, blue] (-1.5, -0.2) -- (1.5, -0.2);
 \draw [ultra thick, dashed, red] (-1.5, 0.2) -- (1.5, 0.2);
  \fill[fill=red, opacity=0.2]  (-1.5, 0)--(-1.5,0.4)--(1.5,0.4)--(1.5,0)--(-1.5,0);
 \end{tikzpicture}
 \end{center}
\begin{mathpar}
\inferrule* [right=inside]
  { }
  {p < \cdot < q \vdash \bigvee \{ x < \cdot < y \suchthat p < x < y < q \}}
\end{mathpar}
\end{subfigure}}

\end{center}
\end{figure}
\end{frame}



\begin{frame}{Running $\R$}
\begin{mathpar}
\inferrule* [right=]
  {\varepsilon : \rat^+}
  {\top \vdash_\R \bigvee_{q : \rat} q - \varepsilon < \cdot < q + \varepsilon}
\end{mathpar}

\[
\Downarrow : \Space \to \Type \to \Type
\]

\begin{mathpar}
\inferrule* [right=]
  {\varepsilon : \rat^+}
  {\R \Downarrow \rat}
\end{mathpar}

\end{frame}

\begin{frame}{Topology, briefly}
\begin{itemize}
\item a \emph{space} $X$ is a set of observable properties (``opens'') together with axioms relating them
\bigskip
\item a \emph{point} of $X$ assigns consistent truth values to observable properties (a model)
\bigskip
\item a \emph{continuous map} $f : X \to Y$ (consistently) describes properties of $Y$ in terms of the properties of $X$
\bigskip
\item Geometric logic: $\top$, $\bot$, finitary $\wedge$, infinitary $\bigvee$
\end{itemize}
\end{frame}

\begin{frame}{Computing with spaces}
\begin{itemize}
\item Proofs are used to compute!
\item products, disjoint union, probability distributions, powerspaces
\item mathematical laws hold
\item no rounding error or overflow
\end{itemize}

\pause

\begin{center}
How to write programs?
\\ How to prove things about them?
\end{center}
\end{frame}

\begin{frame}{Buridan's autonomous car}

\begin{center}
\only<1-2>{\Huge $\R \to \bool$}
\only<3>{\Huge $\R \to \PLower(\bool)$}

 \begin{tikzpicture}
 \draw [<->, ultra thick] (-5, 0) -- (5, 0);
 \draw [(->, ultra thick, green] (-2, 0.2) -- (5, 0.2);
 \draw [<-), ultra thick, red] (-5, 0.4) -- (2, 0.4);
 \node[inner sep=0pt, anchor=south] (car) at (-2.5, 0.6)
    {\includegraphics[width=.25\textwidth]{images/car.png}};
 \node[inner sep=0pt, anchor=south] (light) at (3.5,0.6)
    {\includegraphics[width=.1\textwidth]{images/traffic-light.png}};
 \end{tikzpicture}
 \end{center}

\only<2>{ 
 \begin{align*}
 \mathsf{brake?} &: \R \to \bool
\\ \mathsf{brake?}(x) &\triangleq x \le 0
 \end{align*}
 }
 \only<3>{ 
 \begin{align*}
 \mathsf{brake?} &: \R \to \PLower(\bool)
\\ \mathsf{brake?}(x) &\triangleq \, ?
 \end{align*}
 }
 
\end{frame}

\note{Even with floating point, it is usually a bad idea to write a program that makes hard comparisons like this. It's unstable, and this is explained by topological concerns.}

\begin{frame}{The non-deterministic powerspace $\PLower(A)$}

Variables:
\begin{mathpar}
\inferrule{P : \Open(A)}
  {\lozenge P : \Open(\PLower(A))}
\end{mathpar}

Axioms:
\begin{mathpar}
\inferrule
  {}
  {\lozenge \left( \bigvee_{i : I} P_i \right) {\dashv \vdash}_{\PLower(A)} \bigvee_{i : I} \lozenge P_i}

\inferrule
  {}
  {\top \vdash_{\PLower(A)} \lozenge \top_A}
\end{mathpar}

\pause
\hrule

\begin{mathpar}
\inferrule{P \vdash_A \bigvee_{i : I} Q_i}
  {\lozenge P \vdash_{\PLower(A)} \bigvee_{i : I} \lozenge Q_i}

\inferrule{A \Downarrow I}{\PLower(A) \Downarrow I}
\end{mathpar}
\end{frame}

\begin{frame}{The car's state}
\begin{center}
\begin{tikzpicture}[scale=2.7]
    % Draw axes
    \draw [<->,thick] (0,2) node (yaxis) [above] {speed}
        |- (3,0) node (xaxis) [right] {distance};
    % Draw two intersecting lines
    \coordinate (a_1) at (1.9, 0);
    \coordinate (a_2) at (1.3, 2);
    \coordinate (b_1) at (2.8, 0);
    \coordinate (b_2) at (0.3, 2);
    \shade[top color=green, bottom color=green, fill opacity=0.5] 
      (a_1) -- (a_2) -- (3,2) -- (3,0) -- cycle;
    \shade[top color=red, bottom color=red, fill opacity=0.5] 
      (b_1) -- (b_2) -- (0, 2) -- (0,0) -- cycle;
    \draw (a_1) -- (a_2);
    \draw (b_1) -- (b_2);
\end{tikzpicture}
 \end{center}

\end{frame}

\begin{frame}{No state uncertainty}
\begin{align*}
\mathsf{brake?} &: \{ \State \suchthat \SafeToGo \vee \SafeToStop \} \to \PLower(\bool)
\\ \mathsf{brake?}(s) &\triangleq \mathsf{cases}(s)
\begin{cases}
\SafeToGo
  \quad &\Longrightarrow \quad
  \{ \mathsf{false} \}
\\
\SafeToStop
  \quad &\Longrightarrow \quad
  \{ \mathsf{true} \}
\end{cases}
\end{align*}

\pause

\begin{mathpar}
\inferrule{\bool \Downarrow \texttt{bool}}
  {\PLower(\bool) \Downarrow \texttt{bool}}
\end{mathpar}

\end{frame}


\begin{frame}{The car's state}
\begin{center}
\begin{tikzpicture}[scale=2.7]
    % Draw axes
    \draw [<->,thick] (0,2) node (yaxis) [above] {speed}
        |- (3,0) node (xaxis) [right] {distance};
    % Draw two intersecting lines
    \coordinate (a_1) at (1.9, 0);
    \coordinate (a_2) at (1.3, 2);
    \coordinate (b_1) at (2.8, 0);
    \coordinate (b_2) at (0.3, 2);
    \coordinate (a_1x) at (2.125, 0);
    \coordinate (a_2x) at (1.525, 2);
    \coordinate (b_1x) at (2.475, 0);
    \coordinate (b_2x) at (0, 1.98);
    \shade<1-2>[top color=green, bottom color=green, fill opacity=0.5] 
      (a_1) -- (a_2) -- (3,2) -- (3,0) -- cycle;
    \shade<1-2>[top color=red, bottom color=red, fill opacity=0.5] 
      (b_1) -- (b_2) -- (0, 2) -- (0,0) -- cycle;
    \shade<3>[top color=green, bottom color=green, fill opacity=0.5] 
      (a_1x) -- (a_2x) -- (3,2) -- (3,0) -- cycle;
    \shade<3>[top color=red, bottom color=red, fill opacity=0.5] 
      (b_1x) -- (b_2x) -- (0, 2) -- (0,0) -- cycle;
    \draw<1-2> (a_1) -- (a_2);
    \draw<1-2> (b_1) -- (b_2);
    
    \coordinate (cx) at (2.02, 0.35);
    
    \fill<2-3>[black] (cx) circle (1pt);
    \draw<2-3>[black] (cx) circle (6pt);

    \draw<3>[dashed] (a_1) -- (a_2);
    \draw<3>[dashed] (b_1) -- (b_2);
    \draw<3> (a_1x) -- (a_2x);
    \draw<3> (b_1x) -- (b_2x);
\end{tikzpicture}
 \end{center}
\end{frame}


\begin{frame}{Probabilistic uncertainty}
\begin{align*}
\mathsf{brake?} &: \{ \Prob(\State) \suchthat \Pr[\SafeToGo] > 99\% \vee \Pr[\SafeToStop] > 99\% \} 
\\ &\to \PLower(\bool)
\\ \mathsf{brake?}(s) &\triangleq \mathsf{cases}(s)
\begin{cases}
\Pr[\SafeToGo] > 99\%
   &\Longrightarrow
  \{ \mathsf{false} \}
\\
\Pr[\SafeToStop] > 99\%
   &\Longrightarrow
  \{ \mathsf{true} \}
\end{cases}
\end{align*}
\end{frame}

\begin{frame}{Conclusion}
\begin{itemize}
\item Can perform overlapping pattern match on an open cover
\item \emph{Every} space $A$ naturally has a powerspace $\Prob(A)$ of probability distributions
\note{Not true that every Coq type has a type with its probability distributions.
}
\item Powerspaces can be used for reasoning and computation
\item Coq implementation underway!
\note{Computation with powerspaces doesn't work in Coq (c.f. difficulty with Bishop's notions of compactness)}
\end{itemize}

\pause
\bigskip

\begin{center}
\small Ben Sherman
\\ sherman@csail.mit.edu
\end{center}
\end{frame}

\begin{frame}{Overlapping pattern match semantics}
\begin{mathpar}
\inferrule* [right=]
  {A, B : \Space \\
I : \Type \\
i : I \vdash P_i : \Open(A) \\
i : I \vdash f_i : \{ A \suchthat P_i \} \to B \\
Q : \Open(B) \\
x : \mathsf{Pt}(A) \\
\top \vdash_A \bigvee_{i : I} P_i \\
\forall i, j : I, \exists f_{i,j} : \{ A \suchthat P_i \wedge P_j \} \to B, f_{i,j} = \max(f_i, f_j)
}
  {f(x) \triangleq  \dirsup \{ f_i(x) \suchthat x \models P_i \}}
\end{mathpar}

%should I write this as a directed sup instead? It will likely be unclear no matter what

\[
f(x) = \mathsf{cases}(x) \begin{cases}P_i \Longrightarrow f_i(x) \end{cases}
\]

\end{frame}


\begin{frame}

\begin{tikzpicture}
\node[inner sep=0pt] (highlevel) at (0,0)
  {high level};
\node[inner sep=0pt] (executable) at (0, -6)
  {executable};
\draw[-{Latex[length=4mm, width=3mm]},very thick] (highlevel.south) -- (executable.north);

\node[draw=black, rectangle, inner sep=7pt] (topos) at (5,0)
  {gros topos};
\node[draw=black, rectangle, inner sep=7pt] (cat) at (5,-2)
  {category of spaces};
\node[draw=black, rectangle, inner sep=7pt] (loc) at (7,-4)
  {locales};
\node[draw=black, rectangle, inner sep=7pt] (ft) at (5,-6)
  {formal topology};
  
\draw[-{Latex[length=3mm, width=2mm]},very thick] (topos.south) -- (cat.north);
\draw[-{Latex[length=3mm, width=2mm]},very thick] (cat.south) -- (loc.north);
\draw[-{Latex[length=3mm, width=2mm]},very thick] (cat.south) -- (ft.north);
\draw[-{Latex[length=3mm, width=2mm]},very thick] (loc.south) -- (ft.north);

\end{tikzpicture}


\end{frame}


\begin{frame}
A programming language for continuous spaces which
\begin{enumerate}
\item facilitates formal guarantees
% program with mathematical objects themselves. no approximation error or rounding error. Expected algebraic identities hold
\item ensures programs are robust to perturbations
% every program is continuous
\item facilitates reasoning about uncertainty: non-determinism and probability
% non-determinism and randomness are computational. Also monadic. Every space automatically has probabilistic powerspace (not easy to give probabilistic semantics for other programming languages)
\end{enumerate}
\end{frame}

\begin{frame}{1. Facilitates formal guarantees}
\[
\forall x, y : \R, x + (y - x) = x
\]
\end{frame}

\begin{frame}{2. Is robust to perturbations}
\emph{Continuity and robustness of programs} by Swarat Chaudhuri, Sumit Gulwani, and Robert Lublinerman

Any function $A \to B$ is \emph{automatically} continuous
\end{frame}

\begin{frame}{3. Facilitates reasoning about uncertainty}
\begin{itemize}
\item \emph{Every} space has a probabilistic powerspace
\item Non-determinism and randomness have computational meaning
\end{itemize}
\end{frame}

\begin{frame}{What is continuity?}
Indiscernible property of inputs $\Rightarrow$ indiscernable property of outputs

Observable property of output $\Rightarrow$ observable property of input
\end{frame}

%\begin{frame}{3. Facilitates reasoning about uncertainty}
%\end{frame}

\begin{frame}{Running product spaces}

\begin{mathpar}
\inferrule* [right=]
  {\top \vdash_A \bigvee_{i : I} P_i
  \\ \top \vdash_B \bigvee_{j : J} Q_j}
  {\top \vdash_{A \times B} \bigvee_{(i, j) : I \times J} P_i \times Q_j}
\end{mathpar}

\begin{mathpar}
\inferrule* [right=]
  {A \Downarrow I
  \\ B \Downarrow J}
  {A \times B \Downarrow I \times J}
\end{mathpar}

\end{frame}

\begin{frame}{Geometric theories}
\begin{itemize}
\item propositions are ``affirmable'' properties
\begin{itemize}
  \item if true, one can just ``see it'' to be true
  \item if false, might be impossible to tell
\end{itemize}
\bigskip
\item Connectives $\top$, $\bot$, finitary $\wedge$, infinitary $\bigvee$
\end{itemize}
\end{frame}

\begin{frame}{Non-determistic input uncertainty}
\begin{align*}
\mathsf{brake?} &: \{ \PUpper(\State) \suchthat \square \SafeToGo \vee \square \SafeToStop \} \to \PLower(\bool)
\\ \mathsf{brake?}(s) &\triangleq \mathsf{cases}(s)
\begin{cases}
\square \SafeToGo
  \quad &\Longrightarrow \quad
  \{ \mathsf{true} \}
\\
\square \SafeToStop
  \quad &\Longrightarrow \quad
  \{ \mathsf{false} \}
\end{cases}
\end{align*}
\end{frame}


\end{document}

